<!DOCTYPE html><html lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>Eli | CSC 230: C & Software Tools</title><link href=/styles.css rel=stylesheet><link href=/favicon-32.png rel=icon sizes=32x32><link href=/favicon-128.png rel=icon sizes=128x128><link href=/favicon-180.png rel=icon sizes=180x180><link href=/favicon-192.png rel=icon sizes=192x192><style id=MJX-CHTML-styles>mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}_::-webkit-full-page-media,_:future,:root mjx-container{will-change:opacity}mjx-assistive-mml{position:absolute!important;top:0;left:0;clip:rect(1px,1px,1px,1px);padding:1px 0 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;font-size-adjust:none;letter-spacing:normal;border-collapse:collapse;word-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em 0}mjx-msqrt{display:inline-block;text-align:left}mjx-root{display:inline-block;white-space:nowrap}mjx-surd{display:inline-block;vertical-align:top}mjx-sqrt{display:inline-block;padding-top:.07em}mjx-sqrt>mjx-box{border-top:.07em solid}mjx-sqrt.mjx-tall>mjx-box{padding-left:.3em;margin-left:-.3em}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scalex(1.0000001)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:hidden;overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scalex(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaley(1.0000001);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:hidden;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-mn{display:inline-block;text-align:left}mjx-msup{display:inline-block;text-align:left}mjx-msub{display:inline-block;text-align:left}mjx-TeXAtom{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff) format("woff")}@font-face{font-family:MJXTEX;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-B;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff) format("woff")}@font-face{font-family:MJXTEX-I;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff) format("woff")}@font-face{font-family:MJXTEX-MI;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff) format("woff")}@font-face{font-family:MJXTEX-BI;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff) format("woff")}@font-face{font-family:MJXTEX-S1;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-S2;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-S3;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-S4;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-A;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-C;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-CB;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff) format("woff")}@font-face{font-family:MJXTEX-FR;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-FRB;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff) format("woff")}@font-face{font-family:MJXTEX-SS;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-SSB;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff) format("woff")}@font-face{font-family:MJXTEX-SSI;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff) format("woff")}@font-face{font-family:MJXTEX-SC;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-T;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-V;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-VB;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff) format("woff")}mjx-c.mjx-c1D452.TEX-I::before{padding:.442em .466em .011em 0;content:"e"}mjx-c.mjx-c1D70B.TEX-I::before{padding:.431em .57em .011em 0;content:"\3C0"}mjx-c.mjx-c221A::before{padding:.8em .853em .2em 0;content:"\221A"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c1D703.TEX-I::before{padding:.705em .469em .01em 0;content:"\3B8"}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c2C::before{padding:.121em .278em .194em 0;content:","}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c1D465.TEX-I::before{padding:.442em .572em .011em 0;content:"x"}mjx-c.mjx-c1D466.TEX-I::before{padding:.442em .49em .205em 0;content:"y"}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c1D459.TEX-I::before{padding:.694em .298em .011em 0;content:"l"}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-c1D45C.TEX-I::before{padding:.441em .485em .011em 0;content:"o"}mjx-c.mjx-c1D454.TEX-I::before{padding:.442em .477em .205em 0;content:"g"}mjx-c.mjx-c1D442.TEX-I::before{padding:.704em .763em .022em 0;content:"O"}</style><nav><h2><a href=/ >e l i</a></h2><ul><li><a href=/blog/ >blog</a><li><a href=/projects/ >projects</a><li><a href=/notes/ >notes</a></ul></nav><article><header><h1 class=title>CSC 230: C & Software Tools</h1><p>Instructor: Dr. Susan Balik | Semester: Fall 2019<p><h3>Table of Contents</h3><ul><li><a href=#coding-style>Coding Style</a><li><a href=#compilation>Compilation</a><li><a href=#revision-control>Revision Control</a><li><a href=#debugging>Debugging</a><li><a href=#types-and-variables>Types and Variables</a><li><a href=#standard-library>Standard Library</a><li><a href=#memory-segmentation>Memory Segmentation</a><li><a href=#pointers>Pointers</a><li><a href=#dynamic-allocation>Dynamic Allocation</a><li><a href=#managing-larger-projects>Managing Larger Projects</a><li><a href=#goto>Goto</a><li><a href=#side-effects>Side Effects</a><li><a href=#procedure-evaluation>Procedure Evaluation</a><li><a href=#arrays>Arrays</a><li><a href=#function-pointers>Function Pointers</a><li><a href=#struct>Struct</a><li><a href=#typedef>Typedef</a><li><a href=#data-structures>Data Structures</a><li><a href=#advanced-object-orientation>Advanced Object Orientation</a><li><a href=#handling-binary-data>Handling Binary Data</a><li><a href=#object-oriented-component-design>Object Oriented / Component Design</a><li><a href=#security-safety>Security & Safety</a><li><a href=#enums>Enums</a><li><a href=#unions>Unions</a><li><a href=#odd-keywords>Odd Keywords</a><li><a href=#testing-profiling>Testing & Profiling</a><li><a href=#c>C++</a></ul></header><h1 id=coding-style><a href=#coding-style aria-label="anchor link for coding-style">#</a> Coding Style</h1><p>We use Javadoc-style <a href=http://doxygen.nl/ >Doxygen</a> comments.<p>We avoid magic numbers, instead using constants via preprocessor directives (<code>#define VALUE_NAME &lt;VALUE></code>).<p>Indent with soft tabs (i.e. spaces). One statement per line. End all lines with <code>\n</code>.<p>Avoid global variables because they're really unsafe and it's hard to track their modification.<h1 id=compilation><a href=#compilation aria-label="anchor link for compilation">#</a> Compilation</h1><p>Java uses cross-platform bytecode that the JVM will use on runtime to produce and run machine code. The JVM either uses a bytecode interpreter or Just-In-Time (JIT) compilation. JIT is faster.<p>C directly generates machine code.<ul><li>Java<ul><li>Cross platform bytecode binaries.<li>Can be easier to debug.</ul><li>C<ul><li>Produces faster code.</ul></ul><h2 id=steps><a href=#steps aria-label="anchor link for steps">##</a> Steps</h2><p>The parts are split into a frontend and backend. Frontends deal with the language specifics. Backends deal with the architecture specifics. The middle speaks a standard language.<p>This lets the hardest parts (optimization) be handled in a repeatable way for different languages and architectures.<ul><li>Frontend: preprocessing, lexical analysis, parsing, assembler.<li>Backend: code generation, assembler.</ul><h2 id=preprocessing><a href=#preprocessing aria-label="anchor link for preprocessing">##</a> Preprocessing</h2><p>Goes in and processes all the preprocessor directives (lines that start with <code>#</code>) in the source code.<p>There are a bunch of different kinds of preprocessor directives:<ul><li><code>#define MACRO_NAME(ARGS) MACRO_VALUE</code>: Defines a macro with the given name, which textually expands to the macro value, textually replacing the given arguments.<li><code>#include &lt;filename></code>: Copies the given filename in place of this. This first looks into the system directories and then looks in the current directory.<li><code>#include "filename"</code>: Does the same thing as the above, but looks in the current directory first and then looks into the system directories.</ul><h3 id=macros><a href=#macros aria-label="anchor link for macros">###</a> Macros</h3><p>C preprocessor macros are textual and unhygienic (meaning they can have name collisions). Because of this, you really should only use them for defining constants.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Defining simple constants.
</span><span class="z-c z-meta z-preprocessor z-macro"><span class="z-c z-keyword z-control z-import z-define">#define</span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-constant z-entity z-name z-preprocessor">SIZE</span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-constant z-decimal z-numeric z-integer">5</span></span>
</span></code></pre><p>Macros do allow you to define multi-line functions. These functions are pass-by-name, where they have access to whatever names were present in the code at the time. (Make sure that you aren't using global variables here. Because of variable shadowing, this may not do what you expect.) Also, because of operator precedence, we should surround all variables in parentheses and the entire macro value in parentheses, if we're using multiple operators.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Bad behavior!
</span><span class="z-c z-meta z-preprocessor z-macro"><span class="z-c z-keyword z-control z-import z-define">#define</span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-function z-entity z-name z-preprocessor">TIMES_TWO</span></span><span class="z-c z-meta z-parameters z-macro z-preprocessor"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-variable z-parameter">x</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-preprocessor z-macro"> x <span class="z-c z-keyword z-operator">*</span> <span class="z-c z-constant z-decimal z-numeric z-integer">2</span></span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> this expands to: 1 + 1 * 2 = 3
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">TIMES_TWO</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-constant z-decimal z-numeric z-integer">1</span> <span class="z-c z-keyword z-operator z-arithmetic">+</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Better behavior
</span><span class="z-c z-meta z-preprocessor z-macro"><span class="z-c z-keyword z-control z-import z-define">#define</span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-function z-entity z-name z-preprocessor">TIMES_TWO</span></span><span class="z-c z-meta z-parameters z-macro z-preprocessor"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-variable z-parameter">x</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>x<span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-keyword z-operator">*</span> <span class="z-c z-constant z-decimal z-numeric z-integer">2</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span>
</span></code></pre><p>However, macros do allow for (very limited, very messy) generic programming.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Generic Programming with Macros
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Relying on operators working with types
</span><span class="z-c z-meta z-preprocessor z-macro"><span class="z-c z-keyword z-control z-import z-define">#define</span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-function z-entity z-name z-preprocessor">MAX</span></span><span class="z-c z-meta z-parameters z-macro z-preprocessor"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-variable z-parameter">x</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-variable z-parameter">y</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>x<span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-keyword z-operator z-comparison">></span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>y<span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-keyword z-operator z-ternary">?</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>x<span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-keyword z-operator z-ternary">:</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>y<span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Taking an explicit type
</span><span class="z-c z-meta z-preprocessor z-macro"><span class="z-c z-keyword z-control z-import z-define">#define</span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-function z-entity z-name z-preprocessor">SWAP</span></span><span class="z-c z-meta z-parameters z-macro z-preprocessor"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-variable z-parameter">x</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-variable z-parameter">y</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-variable z-parameter">type</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-punctuation z-section z-begin z-block">{</span> <span class="z-c z-punctuation z-separator z-continuation">\</span>
  type tmp <span class="z-c z-keyword z-operator z-assignment">=</span> x<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-punctuation z-separator z-continuation">\</span>
  x <span class="z-c z-keyword z-operator z-assignment">=</span> y<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-punctuation z-separator z-continuation">\</span>
  y <span class="z-c z-keyword z-operator z-assignment">=</span> tmp<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-punctuation z-separator z-continuation">\</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span>
</span></code></pre><p>You can also control macro expansion using<ul><li><code>#x</code>: Puts quotes around the value <code>x</code> of the given argument. Useful for debugging sometimes.<li><code>x ## y</code>: Puts quotes around the value <code>x</code> and <code>y</code>. Due to implicit string literal concatenation, these concatenate each other.</ul><h3 id=include-guard><a href=#include-guard aria-label="anchor link for include-guard">###</a> Include Guard</h3><h2 id=lexical-analysis><a href=#lexical-analysis aria-label="anchor link for lexical-analysis">##</a> Lexical Analysis</h2><p>Converts source code into tokens.<p>The C scanner / lexical analyzer is a maximal muncher. This means it goes as far as it can with its first guess whenever there is ambiguity.<h2 id=parsing><a href=#parsing aria-label="anchor link for parsing">##</a> Parsing</h2><p>Converts the string of tokens into an Abstract Syntax Tree (AST).<h2 id=optimization><a href=#optimization aria-label="anchor link for optimization">##</a> Optimization</h2><p>Analyzes, modifies, and makes the AST more efficient. This can run few to many times, depending on the compilation parameters.<h2 id=code-generation><a href=#code-generation aria-label="anchor link for code-generation">##</a> Code Generation</h2><p>Converts the AST into a specific architecture's assembly instructions.<h2 id=assembler><a href=#assembler aria-label="anchor link for assembler">##</a> Assembler</h2><p>A specific architecture's assembler goes in and converts the assembly to machine code.<h1 id=revision-control><a href=#revision-control aria-label="anchor link for revision-control">#</a> Revision Control</h1><p>Why do we need revision control? To coordinate work, allow faster conflict resolution, allow people to work on the same file at the same time, etc. Here's an example of revision control systems.<ul><li>SCCS (Source Code Control System, 1972): Centralized<li>RCS (Revision Control System, 1982): Centralized<li>CVS (Concurrent Versioning System, 1990): Centralized<li>SVN (Subversion, 2000): Centralized<li>git (2005): Decentralized</ul><p>Centralized version control has a single, authoritative server/repo. Everyone who checks out from the server just copies the files, with no local repo.<p>Decentralized version control means everyone has a clone of the server. Officially, there is no authoritative copy (although there is an agreed one).<h1 id=debugging><a href=#debugging aria-label="anchor link for debugging">#</a> Debugging</h1><ul><li>GNU Debugger (<code>gdb</code>): A symbolic debugger for your program.<li>Valgrind: A dynamic analysis checker, ensuring that memory is properly allocated, initialized, and freed.</ul><p>We use the GNU Debugger (<code>gdb</code>), for debugging. The GNU Debugger is a symbolic debugger, meaning you get to see and interact with the symbols associated with the memory addresses.<p>Since compilers normally don't store symbol information and other debugging info, you have to add that using the <code>-g</code> flag.<pre class="z-code language-sh" data-lang=sh><code class=language-sh data-lang=sh><span class="z-shell z-bash z-source"><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">$</span></span><span class="z-meta z-function-call z-shell z-arguments"> gcc<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>Wall</span><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>std</span><span class="z-keyword z-operator z-assignment z-option z-shell">=</span>c99<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>g</span> filename.c<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>o</span> filename</span>
<span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">$</span></span><span class="z-meta z-function-call z-shell z-arguments"> gdb ./filename <span class="z-keyword z-control z-regexp z-set z-shell z-begin">[</span>args...<span class="z-keyword z-control z-regexp z-set z-shell z-end">]</span></span>
</span></code></pre><h2 id=gdb-commands><a href=#gdb-commands aria-label="anchor link for gdb-commands">##</a> GDB Commands</h2><p>These all have shortcuts and you can find more by running <code>help</code> in <code>gdb</code>.<ul><li><code>break [procedureName]</code>: Create breakpoint on procedure name.<li><code>break [lineNumber]</code>: Create breakpoint on line number.<li><code>delete [breakpointNumber]</code>: Delete breakpoint.<li><code>condition [breakpointNumber] [condition]</code>: Make breakpoint conditional on condition.<li><code>set variable n = 25</code>: Change the value of a variable.</ul><h3 id=inspecting-code><a href=#inspecting-code aria-label="anchor link for inspecting-code">###</a> Inspecting Code</h3><ul><li><code>print [expression]</code>: Print the value of the expression.<li><code>backtrace</code>: Displace the stack trace.<li><code>up</code>: Look at the variable values in the above stack trace (i.e. child).<li><code>down</code>: Look at the variable values in the below stack trace (i.e. parent).<li><code>list</code>: Look at source code surrounding current statement.<li><code>list [procedureName]</code>: Look at code for procedure.</ul><h3 id=executing-code><a href=#executing-code aria-label="anchor link for executing-code">###</a> Executing Code</h3><ul><li><code>run</code>: Go! You can also do redirection.<li><code>continue</code>: Go until next breakpoint.<li><code>next</code>: Go to next statement.<li><code>step</code>: Go to next statement, going into function calls.<li><code>until [lineNumber]</code>: Run until you hit the line number.<li><code>finish</code>: Go until the function exists.</ul><h2 id=assert-h><a href=#assert-h aria-label="anchor link for assert-h">##</a> <code>assert.h</code></h2><p><strong>Note:</strong> It is recommended to disable assertions in production code (by defining <code>NDEBUG</code>). It is recommended to not disable them during debugging and testing though. Normally, you write <code>assert</code> statements in your procedures to validate input.<p>C allows you to perform easy sanity checks using <code>assert.h</code> (such as bound checks). This provides an <code>assert</code> procedure, that asserts that some given boolean is true, otherwise is crashes the program and prints out information about the issue.<p>It is recommended that you include assert statements to catch errors during development and document assumptions. They can be trivially disabled during production compilation.<h3 id=examples><a href=#examples aria-label="anchor link for examples">###</a> Examples</h3><p>A simple procedure with <code>assert</code>.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-meta z-preprocessor z-include"><span class="z-c z-keyword z-control z-import z-include">#include</span> <span class="z-c z-string z-quoted z-include z-lt-gt z-other"><span class="z-c z-punctuation z-definition z-string z-begin">&lt;</span>assert.h<span class="z-c z-punctuation z-definition z-string z-end">></span></span>
</span>
<span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">f</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-type z-storage">int</span> <span class="z-c z-variable z-parameter">a</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-type z-storage">int</span> <span class="z-c z-variable z-parameter">b</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function">
</span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">assert</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"> a <span class="z-c z-keyword z-operator z-comparison">!=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span> <span class="z-c z-keyword z-operator z-arithmetic">&&</span> b <span class="z-c z-keyword z-operator z-comparison">></span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span> </span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-operator z-variadic">...</span>
</span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><p>Compiling.<pre class="z-code language-sh" data-lang=sh><code class=language-sh data-lang=sh><span class="z-shell z-bash z-source"><span class="z-line z-comment z-number-sign z-shell"><span class="z-punctuation z-begin z-definition z-comment z-shell">#</span></span><span class="z-line z-comment z-number-sign z-shell"> No debugging</span><span class="z-line z-comment z-number-sign z-shell">
</span><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">$</span></span><span class="z-meta z-function-call z-shell z-arguments"> gcc<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>DNDEBUG</span><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>std</span><span class="z-keyword z-operator z-assignment z-option z-shell">=</span>c99<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>Wall</span> ...</span>
<span class="z-line z-comment z-number-sign z-shell"><span class="z-punctuation z-begin z-definition z-comment z-shell">#</span></span><span class="z-line z-comment z-number-sign z-shell"> With debugging</span><span class="z-line z-comment z-number-sign z-shell">
</span><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">$</span></span><span class="z-meta z-function-call z-shell z-arguments"> gcc<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>g</span><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>std</span><span class="z-keyword z-operator z-assignment z-option z-shell">=</span>c99<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>Wall</span> ...</span>
</span></code></pre><h2 id=valgrind><a href=#valgrind aria-label="anchor link for valgrind">##</a> Valgrind</h2><p>Valgrind is a dynamic error detection tool. It runs your code in a VM using JIT compilation. It adds several error-checking instructions in your code. It can also use <em>symbol information</em>, so you should generally use <code>-g</code> to compile with symbolic debugging information.<p><strong>Note:</strong> This causes significant overhead. 10-100x.<p>Valgrind has several tools, but you can only run one at a time.<p>By default, it uses <code>memcheck</code>, which checks for misuse of heap-allocated memory, out of bounds memory access for heap-allocated memory (not stack or static), and leaked memory (with <code>--leak-check=full</code>). There are options for this, such as <code>--track-fds=yes</code> that tracks file descriptors.<p>There's an experimental tool called <code>exp-sgcheck</code> that does <code>s</code>tatic and <code>g</code>lobal bounds checking. It uses heuristics and may return false positives and false negatives.<p><strong>Note:</strong> Valgrind produces a lot of output. Most of it useful.<h3 id=examples-1><a href=#examples-1 aria-label="anchor link for examples-1">###</a> Examples</h3><pre class="z-code language-sh" data-lang=sh><code class=language-sh data-lang=sh><span class="z-shell z-bash z-source"><span class="z-line z-comment z-number-sign z-shell"><span class="z-punctuation z-begin z-definition z-comment z-shell">#</span></span><span class="z-line z-comment z-number-sign z-shell"> Compile your program with symbol information</span><span class="z-line z-comment z-number-sign z-shell">
</span><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">$</span></span><span class="z-meta z-function-call z-shell z-arguments"> gcc<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>g</span><span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>std</span><span class="z-keyword z-operator z-assignment z-option z-shell">=</span>c99 –Wall program.c<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>o</span> program</span>

<span class="z-line z-comment z-number-sign z-shell"><span class="z-punctuation z-begin z-definition z-comment z-shell">#</span></span><span class="z-line z-comment z-number-sign z-shell"> General usage</span><span class="z-line z-comment z-number-sign z-shell">
</span><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">$</span></span><span class="z-meta z-function-call z-shell z-arguments"> valgrind valgrind-options ./program args</span>

<span class="z-line z-comment z-number-sign z-shell"><span class="z-punctuation z-begin z-definition z-comment z-shell">#</span></span><span class="z-line z-comment z-number-sign z-shell"> Example usage</span><span class="z-line z-comment z-number-sign z-shell">
</span><span class="z-line z-comment z-number-sign z-shell"><span class="z-punctuation z-begin z-definition z-comment z-shell">#</span></span><span class="z-line z-comment z-number-sign z-shell"> You could --tool=toolname, but memcheck is</span><span class="z-line z-comment z-number-sign z-shell">
</span><span class="z-line z-comment z-number-sign z-shell"><span class="z-punctuation z-begin z-definition z-comment z-shell">#</span></span><span class="z-line z-comment z-number-sign z-shell"> the default (and what we'll use)</span><span class="z-line z-comment z-number-sign z-shell">
</span><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">$</span></span><span class="z-meta z-function-call z-shell z-arguments"> valgrind<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> --</span>leak-check</span><span class="z-keyword z-operator z-assignment z-option z-shell">=</span>full ./program</span>
</span></code></pre><h2 id=cppcheck><a href=#cppcheck aria-label="anchor link for cppcheck">##</a> CPPCheck</h2><p>CPPCheck (<code>cppcheck</code>) is a static analysis tool. It's not great, but it can catch un-obfuscated issues bound access.<h1 id=types-and-variables><a href=#types-and-variables aria-label="anchor link for types-and-variables">#</a> Types and Variables</h1><h2 id=standard-fundamental-types><a href=#standard-fundamental-types aria-label="anchor link for standard-fundamental-types">##</a> Standard/Fundamental Types</h2><p>C has a fairly rich standard library of types, but it doesn't mandate much about actual sizes. That means the size is <em>platform dependent</em>. See <code>limits.h</code> for your platform's sizes.<p>We have integral values. For every type, there is a <code>signed</code> and <code>unsigned</code> version. By default things are <code>signed</code>.<ul><li><code>long long</code>: At least 64 bits or as large as <code>long</code>.<li><code>long</code>: At least 64 bits or as large as <code>int</code>.<li><code>int</code>: At least 32 bits or as large as <code>short</code>.<li><code>short</code>: At least 16 bits or as large as <code>char</code>.<li><code>char</code>: At least 8 bits.</ul><p>We have real values.<ul><li><code>long double</code>: At least as large as <code>double</code>.<li><code>double</code>: Double precision float.<li><code>float</code>: Single precision float.</ul><p>There's also a few "fake" or odd types.<ul><li><code>_Bool</code>: A "fake" type that is an integer underneath. Really, <code>0</code> is <code>false</code> (both integer and float) and anything else is <code>true</code>.<ul><li>This has a strange name to preserve backwards compatibility.<li>If you include <code>stdbool.h</code>, you get the nice preprocessor constants of <code>bool => _Bool</code>, <code>true => 1</code>, and <code>false => 0</code>.</ul><li><code>void</code>: Nothing and anything.</ul><h2 id=making-variables><a href=#making-variables aria-label="anchor link for making-variables">##</a> Making Variables</h2><p>Variables have<ul><li>Name: How the variable is accessed. Must be a legal identifier.<li>Type: How the contents of the variable's memory is organized (and thought about).<li>Scope: Where the variable can be used.<li>Storage Class: How the variable is stored and initialized.</ul><p>C allows for <strong>variable shadowing</strong>. This just means you can declare a new variable of the same name in a narrower scope and you can only access the newer variable with the same name. This should generally be avoided.<h2 id=literals><a href=#literals aria-label="anchor link for literals">##</a> Literals</h2><p>Literals are different from variables because they don't have a name, type, scope, or storage class (well, string literals have <code>static</code> storage).<p>The C compiler infers/coerces your literal to the type required.<p>Adjacent string literals are implicitly concatenated. This is most useful for multi-line strings.<h3 id=integers><a href=#integers aria-label="anchor link for integers">###</a> Integers</h3><p>The compiler infers their type type by treating the number as the smallest type required to store the literal and then using its type promotion semantics.<p>You can specify the type of integers by appending<ul><li><code>U</code> for unsigned.<li><code>L</code> for long.<li><code>LL</code> for long long.</ul><p>Integer literals that start with <code>0</code> are octal. Integer literals that start with <code>0x</code> are hexadecimal.<h3 id=floats><a href=#floats aria-label="anchor link for floats">###</a> Floats</h3><p>Floats are computerized scientific notation. They are split into a sign bit, mantissa, and exponent.<ul><li>Sign Bit: A single bit at the beginning of a list<li>Mantissa: The value part of the number.<li>Exponent: Determines the order of magnitude.</ul><p>Since, scientific notation mandates that the number before the decimal not be zero and binary is only 1s and 0s, we always know that floats start with a 0.<p>Unlike integers, floats cannot have overflow. However, they can have underflow. Since floats represent continuous fields as discrete values using "scientific notation", floats far from zero are fairly imprecise. This means that you can get "stuck" at certain high values because you cannot "jump past" the number, since they're so far apart.<h3 id=strings><a href=#strings aria-label="anchor link for strings">###</a> Strings</h3><p>C is weird and annoying. A string is really just a null-terminated array of characters (i.e. unsigned bytes). Null terminated? Yeah, that just means that a <code>\0</code> ends the array.<p>They can be encoded in any way but normally using ASCII or UTF-8 (or UTF-16 if you're Windows and hate yourself). Here we will use ASCII encoded strings.<p>Since strings are just arrays, you can iterate over them like arrays. However, you can also iterate over them using pointers until you reach a null character! IMO, this is more clear because it is more like a for each loop.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-keyword z-control">for</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span>c <span class="z-c z-keyword z-operator z-assignment">=</span> string<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-keyword z-operator">*</span>c <span class="z-c z-keyword z-operator z-comparison">!=</span> <span class="z-c z-string z-quoted z-single"><span class="z-c z-punctuation z-definition z-string z-begin">'</span><span class="z-c z-constant z-character z-escape">\0</span><span class="z-c z-punctuation z-definition z-string z-end">'</span></span><span class="z-c z-punctuation z-terminator">;</span> c<span class="z-c z-keyword z-operator z-arithmetic">++</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Using pointers. Means you can avoid array
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> syntax.
</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span>
<span class="z-c z-keyword z-control">for</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">int</span> i <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-terminator">;</span> string<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span>i<span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span> i<span class="z-c z-keyword z-operator z-arithmetic">++</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Using arrays, along with the null
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> terminator (0) being falsey.
</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span>
</span></code></pre><h2 id=type-promotion><a href=#type-promotion aria-label="anchor link for type-promotion">##</a> Type Promotion</h2><p>In C, some integers are considered "more specific"/wider while others are "less specific"/narrower. Narrower numbers are automatically casted to the wider numbers. This is called type promotion and it follows the following graph.<figure><img src=type_promotion.png><figcaption><p>Type Promotion Graph</figcaption></figure><p>Integers specifically have the concept of rank, which is basically the same thing as narrow vs wide. A <code>int</code> is a higher rank than a <code>short</code>. A <code>int</code> is the same rank as a <code>int</code>.<p>The following rules apply in the following order.<ol><li>A lower rank integer of a certain sign-ness is promoted to a higher rank integer of the same sign-ness.<li>A lower rank unsigned integer is promoted to a higher rank signed integer (since they can fit). This occurs automatically when a same-rank signed and unsigned integer interact; they both get promoted to a higher rank signed.<li>A same rank signed integer becomes a same rank unsigned integer if you can't promote them both.</ol><p>These semantics are summed up by the following flow charts.<figure><img src=integer_rank1.png><figcaption><p>Integer Rank 1</figcaption></figure><figure><img src=integer_rank2.png><figcaption><p>Integer Rank 2</figcaption></figure><figure><img src=integer_rank3.png><figcaption><p>Integer Rank 3</figcaption></figure><h2 id=operators><a href=#operators aria-label="anchor link for operators">##</a> Operators</h2><p>There's bunch of friends we get from Java, so I'll only cover the new ones.<p>The <code>sizeof &lt;TYPE></code> operator returns the number of bytes in a type. For integers, this is the special <code>size_t</code> type.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">int</span> bro <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group"> <span class="z-c z-type z-storage">int</span> </span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>Since C has type promotion, you don't always need casting, but it helps the compiler and allows you to shrink types explicitly. You can always explicitly throw away values by casting to <code>void</code>.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Convert long to short
</span><span class="z-c z-type z-storage">short</span> a <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">short</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-constant z-decimal z-numeric z-integer">123<span class="z-c z-type z-storage z-numeric">L</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Explicitly throw away return value
</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">void</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">getchr</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h1 id=standard-library><a href=#standard-library aria-label="anchor link for standard-library">#</a> Standard Library</h1><p>A great resource is <a href=http://www.cplusplus.com/ >http://www.cplusplus.com/</a>.<h2 id=stdio-h><a href=#stdio-h aria-label="anchor link for stdio-h">##</a> <code>stdio.h</code></h2><p>C uses <strong>streams</strong> for IO. A stream is just a stream of characters/bytes and is an abstraction of all input. There all three standard streams:<ul><li><p><code>stdout</code> (0): Normal, expected output.<li><p><code>stderr</code> (2): Exceptional output.<li><p><code>stdin</code> (1): Normal input.<li><p><code>int getchar()</code>: Reads a single character from stdin as an int.<li><p><code>void putchr(int)</code>: Outputs a single character into stdout.<li><p><code>int printf(const *char, ...)</code>: Outputs a string into stdout using the format string followed by the arguments/values for the format specifers in the format string.<li><p><code>int scanf(const *char, ...)</code>: Outputs format string to stdout, pausing for input whenever it reaches an input specifier. It then tries to parse the input correctly and put it into the corresponding pointer in the arguments after the format string. The pointers are used in the order given. Returns number of successfully parsed values. <strong>This fails fast and matches greedily.</strong></ul><h3 id=file-io><a href=#file-io aria-label="anchor link for file-io">###</a> File IO</h3><p><code>stdio.h</code> includes opaque <code>FILE</code> structs which are used to interact with file streams. These streams are only interacted with through procedures provided by <code>stdio.h</code>. The earlier standard streams are also provided as preprocessor macros that expand to specific <code>FILE</code> structs.<p>Most OSes limit the number of files a process can have. This is both practical and acts as a small stopgap for malpractice. In Linux, we can have 1024 open files (meaning Linux gives us 10 bits). In practice we can only have 1021 because of <code>stdout</code>, <code>stderr</code>, and <code>stdin</code>.<ul><li><code>FILE *fopen(const char *filename, const char *mode)</code>: Returns a file pointer to the desired file.<li><code>int fclose(FILE *filestream)</code>: Closes the given file stream. This is important because file streams use buffering (aka caching) and the OS limits the number of files we can have.<li><code>int feof(FILE *stream)</code>: Returns true if <code>EOF</code> has been read by any file IO class. This is set by the reading functions.<ul><li><strong>You should generally not use this because it is error prone</strong>. Really, just think about what's happening.</ul><li><code>int ferror(FILE *stream)</code>: Returns true if any operation on the file failed/errored. This is error is set whenever any operation fails. No future successful operations will overwrite this error flag.<li><code>void clearerr(FILE *stream)</code>: Clears the error flag from the file. Must be called manually, otherwise errors will never be cleared.<li><code>int fprintf(FILE *filestream, const char *format, ...)</code>: Like <code>printf</code>, except it prints into the given file stream.<li><code>int fscanf(FILE *filestream, const char *format, ...)</code>: Like <code>scanf</code>, except it scans from the given file stream.<li><code>int fgetc(FILE *stream)</code>: Like <code>getchar</code> but reads from the given file.<li><code>int getc(FILE *stream)</code>: Same as <code>getc</code>, but may be a macro.<li><code>int ungetc(int c, FILE *stream)</code>: Puts character <code>c</code> back onto the stream and clears the EOF flag. This works even for stdin.<ul><li>You can't write EOF back.<li>This works because streams perform buffering. You can just write some values back to the buffer or scroll back the buffer one.</ul><li><code>int put(FILE *stream)</code>: Same as <code>putc</code>, but may be a macro.<li><code>int fflush(FILE *stream)</code>: Flushes the buffer for the given file. All file IO in C is buffered by default. Returns <code>EOF</code> if failure and sets the error on the stream.<ul><li>stdout normally flushes with new lines.</ul><li><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</code>: Read <code>nmemb</code> members, each with size <code>size</code> into the memory at <code>ptr</code> from file <code>stream</code>. Returns number of bytes read.<li><code>size_t fwrite(void *ptr, size_t size, size_t nmemb, FILE *stream)</code>: Same as <code>fread</code> except it writes to the file stream rather than reading.<li><code>int rewind(FILE *stream )</code>: Restart the file pointer from the start.<ul><li>If you're using this, you're probably doing something you shouldn't.</ul><li><code>int fseek(FILE *stream, long offset, int whence)</code>: Seek to anywhere in the file. Offset can be positive or negative, depending on <code>whence</code>.<ul><li><code>whence</code> tells you with respect to what you're seeking. It can be:<ul><li><code>SEEK_SET</code>: Relative to start.<li><code>SEEK_CUR</code>: Relative to current position.<li><code>SEEK_END</code>: Relative to end of file.</ul><li>This is best for <strong>binary data</strong> because text has inconsistent offsets cross platform, meaning it might "lie" to you.</ul><li><code>long ftell(FILE *stream)</code>: Return current position in file from beginning.<li><code>int remove(const char *pathname)</code>: Remove file.<li><code>int rename(const char *old, const char *new)</code>: Rename file. Return EOF on failure.<li><code>FILE *mktemp()</code>: Create temporary file.</ul><h4 id=buffered-file-io><a href=#buffered-file-io aria-label="anchor link for buffered-file-io">####</a> Buffered File IO</h4><p>Calls to the OS (required for writing/reading files) are costly, so C caches/buffers our desired input and output. When we fill up the buffer, we preform a single call to the OS. This is one reason why closing files is important. Closing a file flushes the buffer by preforming a call to the OS.<h4 id=binary-file-io><a href=#binary-file-io aria-label="anchor link for binary-file-io">####</a> Binary File IO</h4><p>You can open files in text mode or binary mode in C. On the common platform, they happen to be the same but this isn't generally true.<p>Text mode tries to hide some details of the file, such line termination. Meanwhile, binary mode gives you literally the bytes in the file.<h4 id=block-file-io><a href=#block-file-io aria-label="anchor link for block-file-io">####</a> Block File IO</h4><p>Sometimes, reading character by character isn't very useful. We can instead read arbitrary blocks of binary data into any part of our program. This is useful for serialization and deserialization of arbitrary data types.<p>This can also provide a performance advantage.<h4 id=file-open-modes><a href=#file-open-modes aria-label="anchor link for file-open-modes">####</a> File Open Modes</h4><ul><li><code>r</code>: Read<li><code>rb</code>: Read binary<li><code>wb</code>: Write binary<li><code>w</code>: Write<li><code>r+</code>: Read and write<li><code>a</code>: Append</ul><h2 id=string-h><a href=#string-h aria-label="anchor link for string-h">##</a> <code>string.h</code></h2><p><code>string.h</code> is a standard library header file that provides useful procedures for using null-terminated strings:<ul><li><code>int strlen(const char*)</code>: Get the number of characters in the string (excluding the null terminator).<ul><li><strong>Note:</strong> This should not be used for iteration, because it requires looping over the array multiple times.</ul><li><code>char *strcpy(char *dest, const char* src)</code>: Copies the contents of <code>src</code> to <code>dest</code>, up to the first null character in <code>src</code>.<ul><li>It is generally recommended not to use this.<li><strong>Note:</strong> This does not check for <code>dest</code> being too small (because it can't), so you must assure this yourself (or use <code>strncpy</code>).</ul><li><code>char *strncpy(char *dest, const char* src, int n)</code>: Copies the contents of <code>src</code> to <code>dest</code>, up to the first null character in <code>src</code> or the <code>n</code>th character in <code>src</code>, whichever comes first. This prevents overwriting memory.<ul><li>If <code>src</code> is smaller than <code>n</code>, <code>strncpy</code> pads the rest of the characters with zero.<li>This does not put a null character at the end of the string if it runs out of space. To guarantee this, always <em>set the last the last character in the buffer to null</em>.</ul><li><code>char *strcat(char *dest, const char *src)</code>: Appends the characters from <code>src</code> to <code>dest</code> (overwriting and replacing the null character on <code>dest</code>). This may write outside of the buffer and will not always put a null character on the end.<li><code>char *strncat(char *dest, const char *src, size_t n)</code>: Appends the characters from <code>src</code> to <code>dest</code> (overwriting and replacing the null character on <code>dest</code>), where the max length of <code>dest</code> is <code>n</code>. If appending the characters to <code>dest</code> would make it be longer than <code>n</code>, it stops and puts a null character at the end.<ul><li>This <strong>always</strong> puts a null character at the end.</ul><li><code>int strcmp(const char *s1, const char *s2)</code>: Compares <code>s1</code> and <code>s2</code> lexicographically.<ul><li>Returns: <code>&lt; 0</code> when <code>s1 &lt; s2</code>. <code>0</code> when <code>s1 == s2</code>. <code>> 0</code> when <code>s1 > s2</code>.</ul><li><code>int strncmp(const char *s1, const char *s2, size_t n)</code>: Compares <code>s1</code> and <code>s2</code> lexicographically, reading at most <code>n</code> characters from both strings.<ul><li>This is only really useful when you don't have null terminate strings or you only want to compare the first few elements.</ul><li><code>int sscanf(const char *str, const char *format, ...)</code>: Like <code>scanf</code> except reads from <code>str</code> as input. Unlike <code>scanf</code> and <code>fscanf</code>, this does not move the string forward (see <code>str</code> is <code>const</code>).<ul><li>Has special format specifier <code>%n</code>. This writes a <code>char *</code>, holding the position where <code>sscanf</code> left.</ul><li><code>int sprintf(char *str, const char *format, ...)</code>: Like <code>printf</code> except writes to <code>str</code>.<li><code>int snprintf(char *str, size_t size, const char *format, ...)</code>: Like <code>sprintf</code> except it writes at most <code>size</code> bytes including the null character to <code>str</code>. That is, <code>size</code> is the <strong>size</strong> of the string buffer.</ul><p>We also have the following number parsing procedures. When these fail, they return <code>0</code>, so they are not the best way to do this. Generally, you should prefer <code>sscanf</code>.<ul><li><code>int atoi(const char*)</code>: Convert ASCII to integer.<li><code>float atoi(const char*)</code>: Convert ASCII to float.<li><code>double atoi(const char*)</code>: Convert ASCII to double.<li><code>long atol(const char*)</code>: Convert ASCII to long.</ul><h3 id=bounds-inconsistencies><a href=#bounds-inconsistencies aria-label="anchor link for bounds-inconsistencies">###</a> Bounds Inconsistencies</h3><table><thead><tr><th>Procedure<th><code>n</code> Behavior<tbody><tr><td><code>strncpy()</code><td><code>n</code> is a number of characters to write padding with zeros if possible may not null terminate if there's no extra room.<tr><td><code>strncmp()</code><td><code>n</code> is a maximum number of characters to compare will stop when we reach n, when there's a difference or either string ends (at null termination).<tr><td><code>strncat()</code><td><code>n</code> is a maximum number of characters to append not counting the null terminator will always write a null terminator.<tr><td><code>snprintf()</code><td><code>n</code> is a buffer capacity on the destination including the null terminator will always write a null terminator.</table><h3 id=scanf><a href=#scanf aria-label="anchor link for scanf">###</a> <code>scanf</code></h3><p>Since we must manually allocate strings (using character arrays) in C and we are normally fairly lazy (very justifiably), we normally just allocate a large enough character array for usual input. For example,<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> 100 will probably be enough, right? (No)
</span><span class="z-c z-type z-storage">char</span> someString<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">100</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">scanf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%s</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> someString</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>However, C does not bound check arrays, so <code>scanf</code> can and will write more characters than allowed to the array, if the user inputs more than expected. Using the previous example, if the user enters 100 characters, we'd be in trouble (because C adds null terminators, remember?).<p>To guard against this, we can provide <code>scanf</code> a length specifier.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">char</span> someString<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">100</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> now we're safe!
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">scanf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%99s</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> someString</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p><code>scanf</code> also has some oddities with whitespace. Any whitespace in the specifier means gobble all whitespace possible.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> I won't match "2 + 2" but I will match "2+2"
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">scanf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%d</span>+<span class="z-c z-constant z-other z-placeholder">%d</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator">&</span>a<span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator">&</span>b</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> I will match "2 + 2" and "2+2"
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">scanf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%d</span> + <span class="z-c z-constant z-other z-placeholder">%d</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator">&</span>a<span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator">&</span>b</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p><code>scanf</code> also accept regex character classes, so that <code>scanf</code> only accepts things in that character class.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> I accept any upper case letters
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">scanf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%[A-Z]</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator">&</span>string</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> I accept anything but upper case letters
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">scanf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%[^A-Z]</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator">&</span>string</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p><code>scanf</code> allows us to capture but disregard things by placing a <code>*</code> after the <code>%</code>.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">scanf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%*s</span> <span class="z-c z-constant z-other z-placeholder">%s</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator">&</span>onlyOneString</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h3 id=memory-management><a href=#memory-management aria-label="anchor link for memory-management">###</a> Memory Management</h3><ul><li><code>void* memcpy(void* dest, const void* src, size_t count)</code>: Copies <code>count</code> bytes from <code>src</code> to <code>dest</code>. Returns pointer to <code>dest</code>.<ul><li><strong>These must not overlap</strong>.</ul><li><code>void *memmove(void *dest, const void *src, size_t n)</code>: Same as <code>memcpy</code>, but uses a small internal buffer to allow for overlapping regions.<li><code>void *memset(void *s, int c, size_t n)</code>: Set <code>n</code> bytes of memory from <code>s</code> to <code>c</code>.</ul><h2 id=stdlib-h><a href=#stdlib-h aria-label="anchor link for stdlib-h">##</a> <code>stdlib.h</code></h2><p><code>stdlib.h</code> is a giant trash can header file. Anything that doesn't fit well anywhere else gets thrown here.<h3 id=random-numbers><a href=#random-numbers aria-label="anchor link for random-numbers">###</a> Random Numbers</h3><p>C's random number generator is (generally) cryptographically secure, only if it has been <strong>securely seeded</strong>. By default, C's random number generator is not seeded <em>at all</em>.<ul><li><code>int rand()</code>: Generate random number from 0 to <code>RAND_MAX</code>.<li><code>RAND_MAX</code>: Maximum number returned by <code>rand</code>.<li><code>void srand(unsigned int seed)</code>: Seed <code>rand</code> using the given seed. This must be done if you don't want the same numbers every time.<ul><li>Normally, for non-cryptographic contexts, seeding it with the time is sufficient. Do this by doing <code>void srand(time(NULL))</code>.<ul><li><code>time</code> is in <code>time.h</code>.</ul></ul></ul><h3 id=environment-variables><a href=#environment-variables aria-label="anchor link for environment-variables">###</a> Environment Variables</h3><p>C can really easily deal with environment variables (envar), but it can only do so locally to the program.<ul><li><code>char *getenv(const char *varname)</code>: Get value of <code>varname</code> envar.<li><code>void setenv(const char *varname, const char *newValue, int overwrite)</code>: Set value of <code>varname</code> envar to the new value. Doesn't overwrite if <code>overwrite</code> is zero.</ul><h2 id=stdarg-h><a href=#stdarg-h aria-label="anchor link for stdarg-h">##</a> <code>stdarg.h</code></h2><p>C implements variadic functions by providing a bunch of macros in <code>stdarg.h</code>. In C, your variadic function <strong>must</strong> take at least one non-variadic argument. You mark variadic arguments using <code>...</code> as the last argument. The variadic arguments don't need to have a consistent type. C also does not store the type or length of the variadic arguments. Instead, you must essentially treat it like a state machine.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">printf</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-storage z-modifier">const</span> <span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-variable z-parameter">fmt</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator z-variadic">...</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>To use variadic arguments, we must declare a <code>va_list</code>, and then use <code>va_start(list)</code> on it to initialize it. Then, we use <code>va_arg(list, type)</code>, to try to extract a variable of the given type from the list. We then must call <code>va_end(list)</code> to end the list.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">addIntegers</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-type z-storage">int</span> <span class="z-c z-variable z-parameter">n</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator z-variadic">...</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function"> </span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  va_list ap<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> for argument pointer
</span>  <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">va_start</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group">ap<span class="z-c z-punctuation z-separator">,</span> n</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">int</span> total <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-control">for</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">int</span> i <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-terminator">;</span> i <span class="z-c z-keyword z-operator z-comparison">&lt;</span> n<span class="z-c z-punctuation z-terminator">;</span> i<span class="z-c z-keyword z-operator z-arithmetic">++</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
    total <span class="z-c z-keyword z-operator z-assignment z-augmented">+=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">va_arg</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group">ap<span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-type z-storage">int</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-section z-end z-block">}</span></span>
  <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">va_end</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group">ap</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-control z-flow z-return">return</span> total<span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><h3 id=knowing-when-to-stop><a href=#knowing-when-to-stop aria-label="anchor link for knowing-when-to-stop">###</a> Knowing When to Stop</h3><p>As mentioned earlier, C doesn't store the type or length of arguments. To handle this, you can accept some specifiers that you can count (e.g. how <code>printf</code> does it). You can use special final values (e.g. <code>NULL</code>). You can accept an argument specifying the number of arguments.<p><strong>All of these are error prone and rely on you to trust the caller</strong>. Be prepared to fail.<h2 id=setjmp-h><a href=#setjmp-h aria-label="anchor link for setjmp-h">##</a> <code>setjmp.h</code></h2><p><code>setjmp.h</code> is a way to implement exceptions using gotos that can jump across function boundaries (unlike C's normal <code>goto</code>s). However, it is more controlled because you can only jump back to a single marked location, and that marked location must handle different possibilities. It is debated on whether this is a good thing. It can be confusing and hard to track, but you choose! Sometimes it's good.<p>To use this, you first create a <code>jmp_buf</code> that stores <em>your program's entire environment</em>. You then switch on a <code>setjmp</code>, where each of the cases are the possible error codes. (Zero is the initial error code.) Then, the code in the zero case may call <code>longjmp</code> with an int code. This then jumps back to the <code>setjmp</code> where <code>setjmp</code> returns the given int code.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> May long jump
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">readValues</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group">jmp_buf <span class="z-c z-keyword z-operator">*</span><span class="z-c z-variable z-parameter">eenv</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function"> </span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  <span class="z-c z-type z-storage">int</span> sum <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">int</span> m<span class="z-c z-punctuation z-separator">,</span> v<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-control">while</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>m <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">scanf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%d</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator">&</span>v</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-keyword z-operator z-comparison">==</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
    sum <span class="z-c z-keyword z-operator z-assignment z-augmented">+=</span> v<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-section z-end z-block">}</span></span>
  <span class="z-c z-keyword z-control">if</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>m <span class="z-c z-keyword z-operator z-comparison">!=</span> EOF<span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
    <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">longjmp</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-keyword z-operator">*</span>eenv<span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-section z-end z-block">}</span></span>
  <span class="z-c z-keyword z-control z-flow z-return">return</span> sum<span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Handles long jump
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">main</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function"> </span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  jmp_buf eenv<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-control">if</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">setjmp</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"> eenv </span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span> <span class="z-c z-keyword z-operator z-comparison">==</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span> <span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
    <span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">readValues</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-keyword z-operator">&</span>eenv</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-keyword z-control">else</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
    <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">printf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Invalid input!<span class="z-c z-constant z-character z-escape">\n</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-section z-end z-block">}</span></span>
</span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><h3 id=cleaning-up><a href=#cleaning-up aria-label="anchor link for cleaning-up">###</a> Cleaning Up</h3><p>In some cases, we may need to do cleanup of a function that may jump up. To handle this, we do a <code>setjmp</code> in that function and then, in the case of error, clean up and <code>longjmp</code> again. Yes, it's annoying, but welcome to long jump.<h2 id=errno-h><a href=#errno-h aria-label="anchor link for errno-h">##</a> <code>errno.h</code></h2><p>C handles errors by setting a "global int" called <code>errno</code> which is used to represent a bunch of different error conditions. It's not actually a global variable under the covers. It's a transparent preprocessor macro which has some special handling we won't get into.<p>Most <code>errno</code>s you will ever deal with are named, documented, and supported. Each <code>errno</code> has short messages describing then, which can be accessed through <code>perror</code>.<ul><li><code>void perror(const char *s)</code>: Print an error message corresponding to the current error. Prefix it with <code>s</code>.</ul><pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source">FILE <span class="z-c z-keyword z-operator">*</span>fp <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">fopen</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>someFile.txt<span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>r<span class="z-c z-punctuation z-definition z-string z-end">"</span></span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-keyword z-control">if</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>fp <span class="z-c z-keyword z-operator z-comparison">==</span> <span class="z-c z-constant z-language">NULL</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">perror</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>someFile.txt<span class="z-c z-punctuation z-definition z-string z-end">"</span></span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">exit</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-constant z-decimal z-numeric z-integer">1</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span>
</span></code></pre><h2 id=math-h><a href=#math-h aria-label="anchor link for math-h">##</a> <code>math.h</code></h2><p>You have to tell the linker to search for a named library, if it isn't part of the standard C library. For math, you have to supply <code>-lm</code> at the end of the flags. This is because it is a <strong>linker flag</strong> (i.e. <code>LDFLAGS</code>), which must be put at the end of the command.<ul><li><code>M_E</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D452"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>e</mi></math></mjx-assistive-mml></mjx-container>.<li><code>M_PI</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D70B"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>π</mi></math></mjx-assistive-mml></mjx-container>.<li><code>M_SQRT2</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class=mjx-n><mjx-c class=mjx-c221A></mjx-c></mjx-mo></mjx-surd><mjx-box style=padding-top:.174em><mjx-mn class=mjx-n><mjx-c class=mjx-c32></mjx-c></mjx-mn></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msqrt><mn>2</mn></msqrt></math></mjx-assistive-mml></mjx-container>.<li><code>sin(x)</code>: Sine in radians.<li><code>cos(x)</code>: Cosine in radians.<li><code>tan(x)</code>: Tangent in radians.<li><code>asin(x)</code>: Arcsine in radians.<li><code>acos(x)</code>: Arc-cosine in radians.<li><code>atan(x)</code>: Arctangent in radians.<li><code>atan2(y, x)</code>: Find angle <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D703"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>θ</mi></math></mjx-assistive-mml></mjx-container> that points from <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c28></mjx-c></mjx-mo><mjx-mn class=mjx-n><mjx-c class=mjx-c30></mjx-c></mjx-mn><mjx-mo class=mjx-n><mjx-c class=mjx-c2C></mjx-c></mjx-mo><mjx-mn class=mjx-n space=2><mjx-c class=mjx-c30></mjx-c></mjx-mn><mjx-mo class=mjx-n><mjx-c class=mjx-c29></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo stretchy=false>(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy=false>)</mo></math></mjx-assistive-mml></mjx-container> to <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c28></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c2C></mjx-c></mjx-mo><mjx-mi class=mjx-i space=2><mjx-c class="TEX-I mjx-c1D466"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c29></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo stretchy=false>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy=false>)</mo></math></mjx-assistive-mml></mjx-container>.<li><code>exp(x)</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msup><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D452"></mjx-c></mjx-mi><mjx-script style=vertical-align:.363em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msup><mi>e</mi><mi>x</mi></msup></math></mjx-assistive-mml></mjx-container>.<li><code>exp2(x)</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msup><mjx-mn class=mjx-n><mjx-c class=mjx-c32></mjx-c></mjx-mn><mjx-script style=vertical-align:.363em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msup><mn>2</mn><mi>x</mi></msup></math></mjx-assistive-mml></mjx-container>.<li><code>exp10(x)</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msup><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c><mjx-c class=mjx-c30></mjx-c></mjx-mn><mjx-script style=vertical-align:.393em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msup><mn>10</mn><mi>x</mi></msup></math></mjx-assistive-mml></mjx-container>.<li><code>log(x)</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D459"></mjx-c></mjx-mi><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45B"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c28></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c29></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>l</mi><mi>n</mi><mo stretchy=false>(</mo><mi>x</mi><mo stretchy=false>)</mo></math></mjx-assistive-mml></mjx-container>.<li><code>log2(x)</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D459"></mjx-c></mjx-mi><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45C"></mjx-c></mjx-mi><mjx-msub><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D454"></mjx-c></mjx-mi><mjx-script style=vertical-align:-.15em><mjx-mn class=mjx-n size=s><mjx-c class=mjx-c32></mjx-c></mjx-mn></mjx-script></mjx-msub><mjx-mo class=mjx-n><mjx-c class=mjx-c28></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c29></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=false>(</mo><mi>x</mi><mo stretchy=false>)</mo></math></mjx-assistive-mml></mjx-container>.<li><code>log10(x)</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D459"></mjx-c></mjx-mi><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45C"></mjx-c></mjx-mi><mjx-msub><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D454"></mjx-c></mjx-mi><mjx-script style=vertical-align:-.15em><mjx-texatom size=s texclass=ORD><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c><mjx-c class=mjx-c30></mjx-c></mjx-mn></mjx-texatom></mjx-script></mjx-msub><mjx-mo class=mjx-n><mjx-c class=mjx-c28></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c29></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow data-mjx-texclass=ORD><mn>10</mn></mrow></msub><mo stretchy=false>(</mo><mi>x</mi><mo stretchy=false>)</mo></math></mjx-assistive-mml></mjx-container>.<li><code>pow(x, y)</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msup><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi><mjx-script style=vertical-align:.363em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D466"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msup><mi>x</mi><mi>y</mi></msup></math></mjx-assistive-mml></mjx-container>.<li><code>sqrt(x)</code>: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msqrt><mjx-sqrt><mjx-surd><mjx-mo class=mjx-n><mjx-c class=mjx-c221A></mjx-c></mjx-mo></mjx-surd><mjx-box style=padding-top:.281em><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi></mjx-box></mjx-sqrt></mjx-msqrt></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msqrt><mi>x</mi></msqrt></math></mjx-assistive-mml></mjx-container>.<li><code>round(x)</code>: Nearest integer as double.<li><code>fabs(x)</code>: Absolute value.<li><code>floor(x)</code>: Floor.<li><code>ceil(x)</code>: Ceiling.<li><code>fmod(x, y)</code>: Floating point modulus.</ul><h1 id=memory-segmentation><a href=#memory-segmentation aria-label="anchor link for memory-segmentation">#</a> Memory Segmentation</h1><p>Memory in C is segmented into the machine code, statically-allocated data, the heap, and the stack:<figure><img src=memory_segmentation.png><figcaption><p>Memory Segmentation in C</figcaption></figure><p>An important note is that scope isn't the same as storage class. Storage class is an implementation/memory concept, while lifetime is a compiler/coding concept. So, for example, you can create <code>static</code> local variables. This isn't recommended though because it is confusing.<h2 id=machine-code><a href=#machine-code aria-label="anchor link for machine-code">##</a> Machine Code</h2><p>The actual compiled procedures and statements that run your code.<h2 id=static-global-variables><a href=#static-global-variables aria-label="anchor link for static-global-variables">##</a> Static/Global Variables</h2><p>Variables with static storage are initialized at start up (really at compile-time). If you don't initialize them, they have a zero value. If you do, they must be initialized to a constant expression.<p>Note: C isn't very smart with constant expressions. If a global variable A is set to a constant expression and global variable B is set to A. A is considered constant and B is not:<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">char</span> globalC <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-string z-quoted z-single"><span class="z-c z-punctuation z-definition z-string z-begin">'</span>a<span class="z-c z-punctuation z-definition z-string z-end">'</span></span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Yes
</span><span class="z-c z-type z-storage">int</span> globalI <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">15</span> <span class="z-c z-keyword z-operator z-arithmetic">+</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-constant z-decimal z-numeric z-integer">39</span> <span class="z-c z-keyword z-operator z-arithmetic">%</span> <span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Yes
</span><span class="z-c z-type z-storage">int</span> globalJ <span class="z-c z-keyword z-operator z-assignment">=</span> globalI <span class="z-c z-keyword z-operator z-arithmetic">+</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> No
</span></span></code></pre><h2 id=heap><a href=#heap aria-label="anchor link for heap">##</a> Heap</h2><p>Data from the heap is explicitly requested and is explicitly released.<h2 id=stack><a href=#stack aria-label="anchor link for stack">##</a> Stack</h2><p>All local variables are initialized on the stack by default. Variables initialized on the stack must have a size known at compile-time. Otherwise, you must allocate it dynamically on the heap and store a reference/pointer to it.<h1 id=pointers><a href=#pointers aria-label="anchor link for pointers">#</a> Pointers</h1><p>In C, <strong>everything</strong> is passed by value. To get around always copying the data we care about, we use pointers and dereferencing. <em><strong>Creating diagrams where variable are nodes are your friend!</strong></em><p>Pointers are simply memory addresses with a method of getting the value at that memory address. Really, pointers are to the start of a memory block and the type of the pointer determines the size of the block.<p>When declaring a pointer, the number of asterisks (<code>*</code>) describes how deep you have to go before you reach the given type. I personally think this is easiest to understand by postfixing the type with <code>*</code>, since it is distinct from dereferencing, but that isn't always standard.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">int</span> a<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> just a int
</span><span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span>b<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> pointer to a char
</span><span class="z-c z-type z-storage">float</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-keyword z-operator">*</span>c<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> pointer to a pointer to a float
</span></span></code></pre><p>When using a declared pointer, you can use the <strong>dereference operator</strong> by prefixing the name by <code>*</code>. This says to follow the pointer to get the value of that memory address. (You technically could do this for any <code>size_t</code>, but that's unsafe and error-prone so C stops you.) This can be applied <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45B"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>n</mi></math></mjx-assistive-mml></mjx-container> times where <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45B"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>n</mi></math></mjx-assistive-mml></mjx-container> is the number of asterisks you used when declaring the pointer (i.e. how deep the pointer is).<p>When using any variable, you can use the <strong>address of</strong> operator by prefixing the name by <code>&</code>. This gets the address of the variable in memory. (You can't apply this multiple times because C doesn't implicitly declare a variable when using <code>&</code>, so there is no memory address to get for <code>&&</code>.)<p>Putting it all together.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">int</span> a <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">5</span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> int 'a' with value 5.
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span>pa<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> int pointer 'pa'.
</span>pa <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span>a<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> make pa point to a.
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Do the same but briefer
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span>pa <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span>a<span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">int</span> a <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">5</span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> int
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span>pa <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span>a<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> int pointer
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-keyword z-operator">*</span>ppa <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span>pa<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> int double pointer
</span>
<span class="z-c z-keyword z-operator">*</span>pa <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-keyword z-operator">*</span>ppa <span class="z-c z-keyword z-operator z-arithmetic">+</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> a = 6, *pa = 6, **ppa = 6
</span></span></code></pre><p>There also exists a special macro constant called <code>NULL</code>. This is just <code>*0</code>. This just means a pointer to memory address 0, which is either an invalid or protected segment of memory.<p>Wait a minute! You just said we can have pointers to invalid/protected segments of memory. We can also do pointer arithmetic to directly muck with pointers. Isn't this unsafe?<p><strong>Yes!</strong> Trying to access an invalid segment of memory causes your OS to immediately terminate your program with a "segmentation fault". This is like the <code>NullPointerException</code> from Java except unrecoverable.<p><strong>Note:</strong> Pointers in C do not follow type promotion semantics because they use type to determine how much memory they look at. For example, if you wanted to make a <code>int*</code> point to a <code>char</code>, the pointer would look for 4 bytes while the <code>char</code> only is 1 byte. (You can silence these with casting, but why would you want to?)<h2 id=some-odd-syntax><a href=#some-odd-syntax aria-label="anchor link for some-odd-syntax">##</a> Some Odd Syntax</h2><p>It is important to realize that <code>[]</code> (arrays) have higher precedence than <code>*</code> when declaring. This means<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> I am an array of 10 int pointers
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span>ap<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span> <span class="z-c z-constant z-decimal z-numeric z-integer">10</span> <span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> I think this is clearer here
</span><span class="z-c z-type z-storage">int</span><span class="z-c z-keyword z-operator">*</span> ap<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">10</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p><code>const</code> is another type operator (like <code>[]</code> or <code>*</code>). This just says, don't let me change this value during it's lifetime. This has some non-obvious interactions with pointers. Most of the time, you'll just use <code>const</code> pointers to declare to users that you won't change the value.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> pointer to a const int
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-storage z-modifier">const</span> <span class="z-c z-keyword z-operator">*</span> x <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span>a<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> const pointer to a int
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span> <span class="z-c z-storage z-modifier">const</span> y <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span>b<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> const pointer to a const int
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-storage z-modifier">const</span> <span class="z-c z-keyword z-operator">*</span> <span class="z-c z-storage z-modifier">const</span> z <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span>c<span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p><em>Hint:</em> In general, you should read <code>const</code> and points backwards.<h2 id=pointer-arithmetic><a href=#pointer-arithmetic aria-label="anchor link for pointer-arithmetic">##</a> Pointer Arithmetic</h2><p>You can do integer arithmetic directly on pointers. When you add a number <code>n</code> to a pointer <code>p</code>, you're actually shifting the pointer over by <code>n</code> times the <code>sizeof(*p)</code>. For example<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> These are all play examples
</span><span class="z-c z-type z-storage">short</span> <span class="z-c z-keyword z-operator">*</span>a <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-terminator">;</span>
a <span class="z-c z-keyword z-operator z-arithmetic">+</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> shifts a over 2 bytes
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span>b <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-terminator">;</span>
b <span class="z-c z-keyword z-operator z-arithmetic">+</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> shifts b over 4 bytes
</span></span></code></pre><p>Using this, you can really easily see that array notation is really syntactic sugar for pointer arithmetic, which means you can use array notation for any pointer! So,<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">int</span> i<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-type z-storage">int</span> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">10</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span>i<span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-comparison">==</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>a <span class="z-c z-keyword z-operator z-arithmetic">+</span> i<span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>Weirdly, this means you can also swap the array and the index because addition is commutative.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">int</span> i<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-type z-storage">int</span> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">10</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
i<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span>a<span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-comparison">==</span> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span>i<span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p><em>Why do we use arrays at all then?</em> Well, static arrays have stronger type checking (can't change their length) and <code>sizeof</code> returns the number of bytes in the static array, rather than the number of bytes in the pointer.<h2 id=pointer-iteration><a href=#pointer-iteration aria-label="anchor link for pointer-iteration">##</a> Pointer Iteration</h2><p>You can use pointers to iterate over collections. This is generally more performant as you don't have to do integer arithmetic and incrementation every loop. Just incrementation.<p>However, this is generally pretty overkill because integer arithmetic is very cheap, and the compiler is very good. It also is a little harder to think about, so it's not recommended unless you have a <strong>good</strong> reason to do so.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">int</span> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">4</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">9</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">16</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">25</span> <span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-type z-storage">int</span> len <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group"> a </span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-keyword z-operator z-arithmetic">/</span> <span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group"> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span> <span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> </span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> This points right after the array. This is
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> okay as long as we don't dereference it
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span>end <span class="z-c z-keyword z-operator z-assignment">=</span> a <span class="z-c z-keyword z-operator z-arithmetic">+</span> len<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-type z-storage">int</span> sum <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-keyword z-control">for</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span> <span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span>p <span class="z-c z-keyword z-operator z-assignment">=</span> a<span class="z-c z-punctuation z-terminator">;</span> p <span class="z-c z-keyword z-operator z-comparison">&lt;</span> end<span class="z-c z-punctuation z-terminator">;</span> p<span class="z-c z-keyword z-operator z-arithmetic">++</span> <span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  sum <span class="z-c z-keyword z-operator z-assignment z-augmented">+=</span> <span class="z-c z-keyword z-operator">*</span>p<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span>
<span class="z-c z-keyword z-control z-flow z-return">return</span> sum<span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h2 id=void-pointers><a href=#void-pointers aria-label="anchor link for void-pointers">##</a> Void Pointers</h2><p>Sometimes, you're lazy or can't know about what your pointer points to. To handle this, we use void pointers, which are just memory addresses that can point to anything. We receive void pointers from <code>malloc</code>, which we'll get later.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">void</span> <span class="z-c z-keyword z-operator">*</span>ptr<span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> We now have a void pointer
</span></span></code></pre><h1 id=dynamic-allocation><a href=#dynamic-allocation aria-label="anchor link for dynamic-allocation">#</a> Dynamic Allocation</h1><p>For the stack, you must know how much memory you want to allocate at compile time so that the compiler will know where to put things without overwriting them. The stack also has limited size. As you can see, <em>the stack is limited</em>.<p>If you want more memory or to dynamically allocate your memory. You need to use the heap. However, you have to (mostly) manually manage this memory using <code>malloc</code> (memory allocate) and <code>free</code> (release allocated memory back to OS).<p>When you use <code>malloc</code>, you as for a certain number of bytes of memory and you will receive a pointer to the first address. If there is no memory, it returns <code>NULL</code>. When you use <code>free</code>, you simply provide the address to the <strong>first address</strong> you received from <code>malloc</code>. <code>free</code> knows how much memory to release because <code>malloc</code> and <code>free</code> track the memory used.<p><code>malloc</code> and <code>free</code> are declared in <code>stdlib.h</code> with the following signature:<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> stdlib.h
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> returns memory address
</span><span class="z-c z-type z-storage">void</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">malloc</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-type z-support z-sys-types">size_t</span> <span class="z-c z-variable z-parameter">size</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> returns `addr` to system allocator
</span><span class="z-c z-type z-storage">void</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">free</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-type z-storage">void</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-variable z-parameter">addr</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>A common usage of dynamic allocation is for large or variable length arrays. This is useful when you don't have enough space, can't know at compile time, or can't be bothered to make it known at compile time. For example,<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-meta z-preprocessor z-include"><span class="z-c z-keyword z-control z-import z-include">#include</span> <span class="z-c z-string z-quoted z-include z-lt-gt z-other"><span class="z-c z-punctuation z-definition z-string z-begin">&lt;</span>stdlib.h<span class="z-c z-punctuation z-definition z-string z-end">></span></span>
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Allocate a dynamic array for 1000 integers
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> how they like to do it
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span>list <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">malloc</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-constant z-decimal z-numeric z-integer">1000</span> <span class="z-c z-keyword z-operator">*</span> <span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group"><span class="z-c z-type z-storage">int</span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> how I like to do it
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">*</span>list <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">malloc</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-constant z-decimal z-numeric z-integer">1000</span> <span class="z-c z-keyword z-operator">*</span> <span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group"><span class="z-c z-keyword z-operator">*</span>list</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h2 id=dynamic-allocation-hazards><a href=#dynamic-allocation-hazards aria-label="anchor link for dynamic-allocation-hazards">##</a> Dynamic Allocation Hazards</h2><p>Dynamic allocation has a lot of issues. Taken together, we call these issues memory safety issues.<ul><li>Segmentation Faults: We forget to check that <code>malloc</code> returns null. Your program will just crash.<li>Buffer Overflow: We try to write outside of our memory bounds. This may cause invalidation of important memory or cause you to read invalid memory.<li>Memory Leak: We forget to use <code>free</code> in certain cases. This causes your program to keep using more and more memory until you crash. You also get performance issues.<li>Mistaken <code>free</code>s: You free memory you didn't <code>malloc</code>.<li>Multiple <code>free</code>s: You free memory multiple times. You might invalidate memory management data structures. May allow that memory to be <code>malloc</code>'d twice.<li>Dangling Pointer / Use After <code>free</code>: You try to access memory after you <code>free</code> it. You'll either get garbage, old invalid data, or malicious code. <em>Really hard to debug</em>.<ul><li>Set the given pointer to <code>NULL</code> to avoid! Then you just crash.</ul></ul><h2 id=dynamic-allocation-benefits><a href=#dynamic-allocation-benefits aria-label="anchor link for dynamic-allocation-benefits">##</a> Dynamic Allocation Benefits</h2><p>Yes, dynamic allocation is more expensive, since you must call the OS. It's also hard to work with.<p>However, it does have benefits. You can store pointers to valid memory across multiple procedure calls. You can allocate larger things. You can allocate things not known at compile time.<p>A great usage of this is <strong>resizing arrays</strong>. This is basically the same as Java. You create some initial array. Then you can add, remove, and access things in it. When you run out of space, you create a new array that's larger, you copy everything from your old array into it, you update your pointer to point into the new memory, and then you free the old memory. It's a good idea to <strong>double the length of the array</strong> each time, because this gives us an amortized cost of <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D442"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c28></mjx-c></mjx-mo><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn><mjx-mo class=mjx-n><mjx-c class=mjx-c29></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>O</mi><mo stretchy=false>(</mo><mn>1</mn><mo stretchy=false>)</mo></math></mjx-assistive-mml></mjx-container>, since <code>malloc</code> is slow.<h2 id=move-and-copy><a href=#move-and-copy aria-label="anchor link for move-and-copy">##</a> Move and Copy</h2><p>C has some convenience methods that allow you to more easily copy arbitrary memory:<ul><li><code>void *memcpy(void *dest, void const *src, size_t n)</code>: Copy <code>n</code> bytes from <code>src</code> to <code>dest</code>, keeping them both.<li><code>void *memmove(void *dest, void const *src, size_t n)</code>: Copy <code>n</code> bytes from <code>src</code> to <code>dest</code>, <code>free</code>ing <code>src</code>.<ul><li>A little more expensive than <code>memcpy</code>.</ul><li><code>void *realloc(void *ptr, size_t size)</code>: Changes the size of the allocated memory address to the given size. It returns the address of the reallocated block.<ul><li>When growing the array, it increases the size in place, if possible. If it can't, it finds where the memory can be allocated and then copies and moves everything over.<li>When shrinking the array, it decreases the size in place, discarding the data that doesn't fit.<li><strong>You should always use the value it returns. Don't assume it will be the same.</strong></ul></ul><h1 id=managing-larger-projects><a href=#managing-larger-projects aria-label="anchor link for managing-larger-projects">#</a> Managing Larger Projects</h1><p>In C, to use variables and functions from other files, you must declare the variable and function prototype for the compiler to allow you to use the values. The linker will link the declarations in the object (<code>*.o</code>) files into a single executable.<p>To declare a variable without allocating it, you must use <code>extern</code> when declaring the variable.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> There exists some global named x. I don't
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> know where, but it's there and I want it.
</span><span class="z-c z-storage z-modifier">extern</span> <span class="z-c z-type z-storage">int</span> x<span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>To declare a function, you just declare the function prototype.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> There exists some global procedure named f. I
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> don't know where, but it's there and I want
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> it.
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">f</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"> <span class="z-c z-variable z-parameter">x</span> <span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>However, every file that uses these globals and functions declared in some file (say <code>stuff.c</code>) must have these exact same declarations to access parts of <code>stuff.c</code>. Manually declaring these dependencies is brittle and annoying. This lead us to header files and the <code>#include</code> preprocessor directive.<h2 id=header-files><a href=#header-files aria-label="anchor link for header-files">##</a> Header Files</h2><p>Header files are C files that contain only declarations of procedures and globals. Each source file (<code>*.c</code>) that exports some procedures or globals declares them in its corresponding header file (<code>*.h</code>). Users then <code>#include</code> the header files from the libraries they want to use.<p>How do these work? Well, <code>#include</code> just pastes the contents of the included file. This gives you the declarations of the header file, allowing you to use the declared items. When you compile the source file (<code>*.c</code>) into an object file (<code>*.o</code>), you have these external declarations that must (or at least should) be defined. Then, when you go to produce the executable, the linker takes your object file along with the object file (<code>*.o</code>) for your library, links the declarations in your object file to the definition/implementations in the library. It then produces an executable.<p><strong>Note:</strong> It is a good practice for a source file to include its own header file. This detects disagreements with declaration and implementation and won't compile if there is one.<p>The linker then takes the object<p>If you put <code>static</code> in front of a global variable or procedure definition, you get internal linkage, meaning others can't use it.<pre class="z-code language-sh" data-lang=sh><code class=language-sh data-lang=sh><span class="z-shell z-bash z-source"><span class="z-line z-comment z-number-sign z-shell"><span class="z-punctuation z-begin z-definition z-comment z-shell">#</span></span><span class="z-line z-comment z-number-sign z-shell"> Compile main.c into main.o but don't link it.</span><span class="z-line z-comment z-number-sign z-shell">
</span><span class="z-meta z-function-call z-shell"><span class="z-variable z-function z-shell">$</span></span><span class="z-meta z-function-call z-shell z-arguments"> gcc<span class="z-variable z-parameter z-option z-shell"><span class="z-punctuation z-definition z-shell z-parameter"> -</span>c</span> main.c</span>
</span></code></pre><h1 id=goto><a href=#goto aria-label="anchor link for goto">#</a> Goto</h1><p>Goto is now considered bad, unsafe, and abstract-breaking. However, this is how machine code does branching, so we'll cover how C does it.<p>Any statement in C can be labeled with a label on its own line like so<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source">label_name<span class="z-c z-keyword z-operator z-ternary">:</span>
<span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">printf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%s</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>bro<span class="z-c z-punctuation z-definition z-string z-end">"</span></span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> more code...
</span>
<span class="z-c z-keyword z-control z-flow z-goto">goto</span> label_name<span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>However, C does have a slightly muzzled goto. You can't goto another label in another procedure/function. You can, however, go to inner and outer code blocks.<h1 id=side-effects><a href=#side-effects aria-label="anchor link for side-effects">#</a> Side Effects</h1><p>Side effects are just when some procedure modifies or manipulates a piece of data directly. This affects the caller sometimes in unexpected ways.<p>This a common source of bugs and is very difficult to fix efficiently in C. Commonly, the solution is just RTFM, which isn't great.<p>Side effects are hard to reason about because they are hard to notice and are strongly affected by performance and sequence points. Sequence points are essentially just where C finishes a statement. These are the following: <code>;</code>, <code>,</code>, <code>&&</code>, <code>||</code>, <code>?</code>.<h1 id=procedure-evaluation><a href=#procedure-evaluation aria-label="anchor link for procedure-evaluation">#</a> Procedure Evaluation</h1><p>The C compiler matches the called procedure's name and its actual parameters with the formal parameters of the procedure.<ul><li><p>Actual Parameters: Types of arguments passed in before types are promoted.<li><p>Formal Parameters: Types of parameters the procedure expects.</ul><p>Procedures in C can only return one value, like Java. This is sad, but we get around it by taking in pointers which we fill with values normally.<h2 id=procedure-declaration><a href=#procedure-declaration aria-label="anchor link for procedure-declaration">##</a> Procedure Declaration</h2><p>We can declare functions, which helps the C compiler be aware of what procedures we have. This is a core part of a header file! (which we haven't gotten to yet). Function declarations look like the following:<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declaration. Variable names are optional, but
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> good for documentation.
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">expunge</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"> <span class="z-c z-type z-storage">float</span> <span class="z-c z-variable z-parameter">x</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-type z-storage">long</span> <span class="z-c z-variable z-parameter">y</span> <span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Definition.
</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">expunge</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"> <span class="z-c z-type z-storage">float</span> <span class="z-c z-variable z-parameter">x</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-type z-storage">long</span> <span class="z-c z-variable z-parameter">y</span> <span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function">
</span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> do things
</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><h2 id=variadic-procedure><a href=#variadic-procedure aria-label="anchor link for variadic-procedure">##</a> Variadic Procedure</h2><p>You can also have variadic arguments via a few special procedures. A variadic function looks something like the following:<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">void</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">printFloats</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"> <span class="z-c z-type z-storage">int</span> <span class="z-c z-variable z-parameter">n</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-keyword z-operator z-variadic">...</span> <span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>We'll get more into this later.<h2 id=performance-considerations><a href=#performance-considerations aria-label="anchor link for performance-considerations">##</a> Performance Considerations</h2><p>It is (somewhat) important to note that procedure calls aren't free (duh!). We have to transfer control to another procedure, by saving the parameters, allocating variables on the stack for the procedure, save the return address, jump to the procedure's address, do the things, clear the stack, and jump back to the caller.<p>In Java, we have procedures (there, methods) check for the validity of their arguments and complain when they are invalid. This is normally a <strong>fantastic idea</strong>; however, this does add additional overhead on calling procedures. If we want a performance boost, when can declare that the procedure shall have undefined behavior for invalid values and thus place the onus of validation on the caller. This is <strong>normally</strong> a <strong>bad idea</strong>, since they aren't that expensive and can remove a whole class of errors.<h1 id=arrays><a href=#arrays aria-label="anchor link for arrays">#</a> Arrays</h1><p>C arrays are syntactically similar to Java.<h2 id=allocation><a href=#allocation aria-label="anchor link for allocation">##</a> Allocation</h2><p>However, in C arrays are either allocated statically or dynamically. Statically allocated arrays must have a constant expression for their length (known at compile time) and because they are allocated on the stack. Dynamically allocated arrays can have a length only known at runtime, but must be allocated on the heap. (We store a pointer to the first element in the array.)<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and allocate an array of length 10
</span><span class="z-c z-type z-storage">int</span> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">10</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and allocate an array of length 10.
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Initialize array to zero.
</span><span class="z-c z-type z-storage">int</span> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">10</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and allocate array and partially
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> initialize it.
</span><span class="z-c z-type z-storage">int</span> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">10</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">2</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and allocate an array large enough to
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> fit the given data.
</span><span class="z-c z-type z-storage">int</span> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">2</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and allocate an array large enough to
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> fit the given data. Giving indexes. Elements
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> unspecified are zeroed.
</span><span class="z-c z-type z-storage">int</span> a<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">2</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">6</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> {0, 0, 0, 1, 2, 0, 3}
</span></span></code></pre><p>In Java, all arrays are dynamically allocated on the heap, but Java manages it behind the scenes.<h2 id=multi-dimensional-arrays><a href=#multi-dimensional-arrays aria-label="anchor link for multi-dimensional-arrays">##</a> Multi-Dimensional Arrays</h2><p>For multi-dimensional arrays, C uses the same syntax as Java.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and allocate 2D array with 3 rows and
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> 4 columns.
</span><span class="z-c z-type z-storage">int</span> table<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">4</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and allocate 2D array with 3 rows and
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> 4 columns. Initialize to zero.
</span><span class="z-c z-type z-storage">int</span> table<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">4</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and allocate 2D array with 3 rows and
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> 4 columns. Initialize values.
</span><span class="z-c z-type z-storage">int</span> table<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">4</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">4</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">9</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-separator">,</span>
  <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-constant z-decimal z-numeric z-integer">16</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">25</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">36</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">49</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-separator">,</span>
  <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-constant z-decimal z-numeric z-integer">64</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">81</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">100</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">121</span> <span class="z-c z-punctuation z-section z-end z-block">}</span></span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and allocate 2D array with 3 rows and
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> 4 columns. Partially initialize values. All
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> other values initialized to zero.
</span><span class="z-c z-type z-storage">int</span> table<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">4</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-separator">,</span>
  <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-constant z-decimal z-numeric z-integer">16</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">25</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">36</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">49</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-separator">,</span>
  <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span><span class="z-c z-constant z-decimal z-numeric z-integer">64</span><span class="z-c z-punctuation z-section z-end z-block">}</span></span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> We also have the special indexing
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> initialization.
</span></span></code></pre><p>C can only infer the size of the outermost array. It cannot for any inner array. It does this because then you would have arrays to pointers, which we'd then have to individually initialize. This syntax is supposed to create a local block of memory. Having an array of pointers to another arrays would not be local. This isn't what what we'd expect, so we don't do it.<p>For some reason, C can only infer the size of the outer array. I haven't quite figured out why it doesn't take the max of the inferred size of the inner arrays. Maybe it's error prone?<p>C arranges multi-dimensional arrays in <strong>row-major order</strong>. Essentially, it arranges everything as a string, where the outer dimension is more significant than the inner. (This is only for <strong>statically allocated</strong> arrays!)<p>This method of memory allocation makes indexing faster. In Java, we have an array on the heap of pointers to other arrays on the heap.<h3 id=unspecified-lengths><a href=#unspecified-lengths aria-label="anchor link for unspecified-lengths">###</a> Unspecified Lengths</h3><p>In C, you can have unspecified lengths for outer arrays, but you <strong>must</strong> have the length for the inner array, if you're initializing this. We'll get into this more in [Arrays are Just Pointers]. However, suffice it to say<h3 id=limitations><a href=#limitations aria-label="anchor link for limitations">###</a> Limitations</h3><p>Since the stack is only so, we can't create HUGE arrays on the stack (e.g. <code>int[1000000]</code>). To normal workaround is to either use the heap or to use a <code>static</code> lifetime array, so the compiler properly plans ahead.<h2 id=variable-length-arrays><a href=#variable-length-arrays aria-label="anchor link for variable-length-arrays">##</a> Variable Length Arrays</h2><p>C99 began to allow for variable length arrays on the stack.<p><strong>TODO: Write more</strong>.<h2 id=arrays-are-just-pointers><a href=#arrays-are-just-pointers aria-label="anchor link for arrays-are-just-pointers">##</a> Arrays are Just Pointers</h2><p>In C, arrays are just pointers with nice syntax for creating and pointer arithmetic. This is easiest to see with procedure parameters (e.g. <code>int test[]</code>). We don't know the size of the array because it's just a pointer!<p>Since we don't know the size of the array, we can't safely iterate over it. To account for this, we normally take length as a parameter.<p><strong>Note:</strong> This requires us to trust the caller. This is another security issue.<h3 id=inner-dimensions><a href=#inner-dimensions aria-label="anchor link for inner-dimensions">###</a> Inner Dimensions</h3><p>You may be confused why we declare the inner dimension of an array in procedures. We don't strictly need to (Java doesn't), but this allows us to have faster, smaller, more local memory. The reason it allows this is because it means C doesn't make your array an array of pointers to arrays, but instead an array of statically allocated arrays.<p>This may be initially confusing, but realize that array syntax is just syntactic sugar for pointer syntax.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> array syntax
</span><span class="z-c z-type z-storage">void</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">foo</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-type z-storage">int</span> <span class="z-c z-variable z-parameter">array</span><span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> pointer syntax, equivalent
</span><span class="z-c z-type z-storage">void</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">foo</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-keyword z-operator">*</span>array<span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">3</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>Now you should be able to more easily see that we need to know what our pointer points to. If we had <code>int array[][]</code>, we'd really just have a double pointer (e.g. <code>int **array</code>). That is, we'd have an array that pointed to other arrays.<p>Sometimes this is what you want, sometimes not.<h2 id=bounds-checking><a href=#bounds-checking aria-label="anchor link for bounds-checking">##</a> Bounds Checking</h2><p>Unlike almost every other language, C has no bounds checks for array access.<p>This basically means you can write or read memory on accident. This is called <strong>buffer overflows</strong>.<p>Sadly, bugs like this normally fail at some future point and cause <em>security</em> issues. Exploits using array bound checking issues are called <strong>stack smashing</strong> exploits. There are several static analysis tools (clang, fortify, etc.)<p>Worst case, these bugs arise as segmentation faults (trying to access memory forbidden by OS). Sometimes you also get a bus error.<h1 id=function-pointers><a href=#function-pointers aria-label="anchor link for function-pointers">#</a> Function Pointers</h1><p>Realize that procedures/functions are really just the address of the first instruction in the procedure. This means we can pass them around and call them! We just need some (type) semantics to make sure the compiler know what to do with args and to be (somewhat) safe.<p>Procedures/functions have a type based off of their parameters and their return value.<h2 id=syntax><a href=#syntax aria-label="anchor link for syntax">##</a> Syntax</h2><p>C has some pretty garbage syntax for function pointers IMO. This comes from it not having a function keyword.<p>Here's a quick breakdown of the syntax.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare a variable called foo which is a
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> pointer to a function that takes in a pointer
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> to a character and returns an integer.
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">int</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-keyword z-operator">*</span>foo</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">char</span><span class="z-c z-keyword z-operator">*</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare a function that takes in a function
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> which takes a character and returns an
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> integer.
</span><span class="z-c z-type z-storage">void</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">someFunc</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-type z-storage">int</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-keyword z-operator">*</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">char</span><span class="z-c z-keyword z-operator">*</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare an array of function pointers. Call
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> this array testList
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">bool</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-keyword z-operator">*</span>testList<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span><span class="z-c z-constant z-decimal z-numeric z-integer">10</span><span class="z-c z-punctuation z-section z-end z-brackets">]</span></span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">int</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>When we assign function pointers, we're technically supposed to use the <code>&</code> address of operator. And then, when we apply them, we should dereference them (<code>*</code>). For example,<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">int</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-keyword z-operator">*</span>funcPtr</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span>func<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Apply it
</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-keyword z-operator">*</span>funcPtr<span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>However, this is pretty garbage syntax for something that is unambiguous, since we can't do arithmetic on function pointers. Therefore, C allows us to not use those operators and instead do this:<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">int</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-keyword z-operator">*</span>funcPtr</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> func<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Apply it
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">funcPtr</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h2 id=why><a href=#why aria-label="anchor link for why">##</a> Why?</h2><p>Well, first off, it allows for basic, low level first class functions, which is rad. More practically, it allows for the strategy pattern, the chain of command pattern, and callbacks.<p>The strategy pattern is where we have a common function that takes a specific function that changes its behavior. Imagine we have a function that plays a game and takes in a strategy, which is itself a function. This allows for easier modification and more code reuse.<p>The chain of command pattern is where we apply a series of functions, taking the first successful output.<h1 id=struct><a href=#struct aria-label="anchor link for struct">#</a> Struct</h1><p>Structs are what has made C last so long.<p>A struct is just a collection of heterogeneously typed, named fields stored contiguously. We access the field of a struct <code>a</code> using <code>a.fieldName</code> struct. We access the field of a struct pointer <code>aPtr</code> using <code>aPtr->fieldName</code>.<p>Structs have unspecified order within the struct. This is so that we can make platform-specific optimizations. For example, most architectures have some sort of "alignment" for their data (e.g. 2-byte alignment, 4-byte alignment). Data that is aligned is faster to access. Data that is not aligned is slower to access.<figure><img src=misaligned_struct.png><figcaption><p>Poorly Aligned Struct, using given order</figcaption></figure><figure><img src=aligned_struct.png><figcaption><p>Well Aligned Struct, overriding given order</figcaption></figure><h2 id=semantics><a href=#semantics aria-label="anchor link for semantics">##</a> Semantics</h2><p>Like everything in C, <code>struct</code>s are passed by value and allocated on the stack. However, you can have enormous structs. Therefore, we normally work with pointers to <code>struct</code>s!<p>When working with <code>struct *</code>s you have the choice of using <code>*</code> with <code>.</code> to deference and get fields, or the nicer <code>-></code> syntax (see [Pointers to Structs]).<p>When returning <code>struct</code>s within procedures, you must be careful. If you return it by value, that might be slow but you'll be safe. If you return a pointer, make sure you won't get a dangling pointer (i.e. make sure that you <code>malloc</code> the <code>struct</code> and later free it in the caller).<h2 id=syntax-1><a href=#syntax-1 aria-label="anchor link for syntax-1">##</a> Syntax</h2><h3 id=named-structs><a href=#named-structs aria-label="anchor link for named-structs">###</a> Named Structs</h3><pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare a struct
</span><span class="z-c z-meta z-struct"><span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-struct"><span class="z-c z-entity z-name z-struct">StructName</span></span></span><span class="z-c z-meta z-struct"> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block">
  type name<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-operator z-variadic">...</span>
</span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare example struct
</span><span class="z-c z-meta z-struct"><span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-struct"><span class="z-c z-entity z-name z-struct">Person</span></span></span><span class="z-c z-meta z-struct"> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block">
  <span class="z-c z-type z-storage">char</span> name<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span> <span class="z-c z-constant z-decimal z-numeric z-integer">12</span> <span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">double</span> height<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">int</span> age<span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span><span class="z-c z-punctuation z-terminator">;</span>


<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare an uninitialized person struct
</span><span class="z-c z-type z-storage">struct</span> Person p1<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Initialize the struct
</span>p1<span class="z-c z-punctuation z-accessor">.</span><span class="z-c z-variable z-member z-other">height</span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-float">1<span class="z-c z-punctuation z-separator z-decimal">.</span>75</span><span class="z-c z-punctuation z-terminator">;</span>
p1<span class="z-c z-punctuation z-accessor">.</span><span class="z-c z-variable z-member z-other">age</span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">24</span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Note that we can't do p1.name = "William"
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> because p1.name is an array and not a pointer
</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">strcpy</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group">p1<span class="z-c z-punctuation z-accessor">.</span><span class="z-c z-variable z-member z-other">name</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>William<span class="z-c z-punctuation z-definition z-string z-end">"</span></span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare and initialize a struct
</span><span class="z-c z-type z-storage">struct</span> Person p2 <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>William<span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-float">1<span class="z-c z-punctuation z-separator z-decimal">.</span>85</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">27</span> <span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> More explicit initialization syntax
</span><span class="z-c z-type z-storage">struct</span> Person p3 <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-punctuation z-accessor">.</span><span class="z-c z-variable z-member z-other">age</span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">33</span><span class="z-c z-punctuation z-separator">,</span>
  <span class="z-c z-punctuation z-accessor">.</span><span class="z-c z-variable z-member z-other">name</span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Agatha<span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span>
  <span class="z-c z-punctuation z-accessor">.</span><span class="z-c z-variable z-member z-other">height</span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-float">1<span class="z-c z-punctuation z-separator z-decimal">.</span>7</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h3 id=anonymous-structs><a href=#anonymous-structs aria-label="anchor link for anonymous-structs">###</a> Anonymous Structs</h3><p>We can declare anonymous <code>struct</code>s by just not giving them a name. These are useful for global <code>struct</code>s (like singletons) or one-time use <code>struct</code>s. No other <code>struct</code> has the same type.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Declare anonymous struct with an instance
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> named varName
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  type name<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-operator z-variadic">...</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">varName</span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Typedef a struct. Basically assign the
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> anonymous struct type to the given. This is
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> hotly debated. I generally don't typedef
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> structs, but it doesn't matter much to me.
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-type z-storage">int</span> foo<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">char</span> bar<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">Example</span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h3 id=pointers-to-structs><a href=#pointers-to-structs aria-label="anchor link for pointers-to-structs">###</a> Pointers to Structs</h3><p>Since <code>struct</code>s are passed by value, like everything in C, and <code>struct</code>s can get large, we like to deal with <code>struct *</code>s. This means, to get a field on the <code>struct *</code>, we must first dereference it (duh). This looks like<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> readStruct returns a pointer to an malloc'd
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> struct. We won't free that here.
</span><span class="z-c z-type z-storage">struct</span> Person <span class="z-c z-keyword z-operator">*</span>p1 <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">readStruct</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">printf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%s</span><span class="z-c z-constant z-character z-escape">\n</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-keyword z-operator">*</span>p1<span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-accessor">.</span><span class="z-c z-variable z-member z-other">name</span></span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>However, this gets really ugly with nested pointers, nested structs, and even basic things like this. Therefore, we invented <code>-></code> syntax, which is just <code>*</code> and <code>.</code> combined. The above would like like<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> readStruct returns a pointer to an malloc'd
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> struct. We won't free that here.
</span><span class="z-c z-type z-storage">struct</span> Person <span class="z-c z-keyword z-operator">*</span>p1 <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">readStruct</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">printf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%s</span><span class="z-c z-constant z-character z-escape">\n</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> p1<span class="z-c z-punctuation z-accessor">-></span>name</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h1 id=typedef><a href=#typedef aria-label="anchor link for typedef">#</a> Typedef</h1><p>Typedef is used by the compiler to create aliases for types (not actually defining new types!).<p>When to use typedef is debated. Generally, you should only do it when you have a <strong>good reason</strong> to. Otherwise, it can add more cognitive load to people keeping track of what your types are.<p><strong>Note:</strong> A typedef only applies after the line on which the typedef occurred, for some reason.<h2 id=syntax-2><a href=#syntax-2 aria-label="anchor link for syntax-2">##</a> Syntax</h2><pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> General Syntax. For types such as arrays, the
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> name must be mixed with the type because C
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> has annoying syntax.
</span><span class="z-c z-type z-storage">typedef</span> TYPE <span class="z-c z-type z-entity z-name z-typedef">IDENTIFIER</span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> "Complex" basic type. Generally not
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> recommended.
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">char</span> Table<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span>NUM_ROWS<span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span>NUM_COLS<span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Pointer type. Strongly advised against.
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-type z-entity z-name z-typedef">str</span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Anonymous enum.
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">enum</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span> NAME1<span class="z-c z-punctuation z-separator">,</span> NAME2 <span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">ExampleEnum</span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Anonymous struct.
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-type z-storage">int</span> field1<span class="z-c z-punctuation z-separator">,</span>
  <span class="z-c z-type z-storage">char</span> field2<span class="z-c z-punctuation z-separator">,</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">ExampleStruct</span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Function. Strongly recommended.
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">void</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">mallocLike</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-type z-support z-sys-types">size_t</span> size</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h2 id=recommendations><a href=#recommendations aria-label="anchor link for recommendations">##</a> Recommendations</h2><p>First off, you should generally not use typedef a bunch. It is very weak in C because you can use the original type and the aliases type interchangeably, so it doesn't add much type safety. It also doesn't allow for any behaviors (like associated methods in Go). Additionally, people don't expect to see several typedefs in C code.<p>You should <strong>never</strong> typedef a pointer type. This adds an incredibly amount of cognitive load, since whether or not a value is a pointer changes both the semantics and the syntax of the type. For example, people could pass their type to a procedure and expect it to be passed by value (because it says it is), but then the procedure mutates their variable.<p>There are two strong cases for using typedef. When you have compiler flags which you want to change the types (using <code>#ifdef</code>) and when you have a complex, completely opaque type to the consumer (opaque means the user does not interact with it directly).<p>Using specific types is normally not necessary unless you have had issues with a specific architecture (don't do premature optimization!). If you do a typedef, then you only have one <code>#ifdef</code>, like<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-meta z-preprocessor"><span class="z-c z-keyword z-control z-import">#ifdef</span> SOME_PREPROCESSOR
</span><span class="z-c z-type z-storage">typedef</span> Something <span class="z-c z-type z-support z-stdint">uint16_t</span>
<span class="z-c z-meta z-preprocessor"><span class="z-c z-keyword z-control z-import">#else</span>
</span><span class="z-c z-type z-storage">typedef</span> Something <span class="z-c z-type z-support z-stdint">uint32_t</span>
<span class="z-c z-meta z-preprocessor"><span class="z-c z-keyword z-control z-import">#endif</span></span>
</span></code></pre><p>An example of a completely opaque type is <code>FILE</code>, where you only interact with it through accessor/mutator procedures. This simplifies the client code and allows you more flexibility with modifying the type.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> We declare the following anonymous struct to
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> have the name OpaqueStruct This means you can
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> use the type as OpaqueStruct instead of
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> struct OpaqueStruct.
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-type z-storage">int</span> field1<span class="z-c z-punctuation z-separator">,</span>
  <span class="z-c z-type z-storage">char</span> field2<span class="z-c z-punctuation z-separator">,</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">OpaqueStruct</span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h1 id=data-structures><a href=#data-structures aria-label="anchor link for data-structures">#</a> Data Structures</h1><p>There are two main ways to keep data organized. You can either keep it all in one place (i.e. arrays and structs), or you can use links/pointers (i.e. linked data structures).<figure><img src=linked_list.png><figcaption><p>Linked List</figcaption></figure><p>Here's a quick comparison of the benefits two<ul><li>Contiguous Memory:<ul><li>Can use (pointer) arithmetic to quickly and randomly access any data.<li>Very simple for fixed-size data.</ul><li>Linked Memory:<ul><li>Easier to grow and add stuff to.<li>Doesn't require large, contiguous section of memory.<li>Are more intuitive for certain data structures (e.g. graphs)</ul></ul><h2 id=linked-list-example><a href=#linked-list-example aria-label="anchor link for linked-list-example">##</a> Linked List Example</h2><pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Create a struct with a useful short name and
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> long name
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> NodeStruct <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-type z-storage">int</span> value<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> We must use struct NodeStruct, because the
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> typedef only applies after the typedef in
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> the file
</span>  <span class="z-c z-type z-storage">struct</span> NodeStruct <span class="z-c z-keyword z-operator">*</span>next<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">Node</span><span class="z-c z-punctuation z-terminator">;</span>

Node <span class="z-c z-keyword z-operator">*</span>head <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">malloc</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group">Node</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-keyword z-operator">*</span>head <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>Node<span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-punctuation z-accessor">.</span><span class="z-c z-variable z-member z-other">value</span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-accessor">.</span><span class="z-c z-variable z-member z-other">next</span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-language">NULL</span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Simple traversal, relying on next being NULL
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> at the end of the list and NULL being falsey
</span><span class="z-c z-keyword z-control">for</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span> Node <span class="z-c z-keyword z-operator">*</span>n <span class="z-c z-keyword z-operator z-assignment">=</span> head<span class="z-c z-punctuation z-terminator">;</span> n<span class="z-c z-punctuation z-terminator">;</span> n <span class="z-c z-keyword z-operator z-assignment">=</span> n<span class="z-c z-punctuation z-accessor">-></span>next <span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">printf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-other z-placeholder">%d</span> <span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-c z-punctuation z-separator">,</span> n<span class="z-c z-punctuation z-accessor">-></span>value </span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span>
<span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">printf</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-character z-escape">\n</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span> </span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><h2 id=simple-object-orientation><a href=#simple-object-orientation aria-label="anchor link for simple-object-orientation">##</a> Simple Object Orientation</h2><p>In C, object orientation is achieved by having procedures that take the first parameter as a pointer to your type. Then, the procedure mutates it as you wish.<p><strong>Note:</strong> This is actually how object orientation works for most languages. In fact, Some languages, such as Go, Rust, and Python, don't even hide this. Their method syntax is explicitly just syntactic sugar around this core feature. I prefer this way!<p>For example, suppose you have a type <code>T</code> and a procedure <code>f</code>. If you want <code>f</code> to mutate a variable of type <code>T</code>, have it accept <code>T*</code> as its first parameter. That is <code>f(T*, ...)</code>.<p>Concretely,<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Use Node from earlier
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  Node <span class="z-c z-keyword z-operator">*</span>head<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">List</span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-type z-storage">void</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">addValue</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group">List <span class="z-c z-keyword z-operator">*</span><span class="z-c z-variable z-parameter">list</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-type z-storage">int</span> <span class="z-c z-variable z-parameter">val</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function">
</span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  Node <span class="z-c z-keyword z-operator">*</span>n <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>Node <span class="z-c z-keyword z-operator">*</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">malloc</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"> <span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group"> Node </span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span> </span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  n<span class="z-c z-punctuation z-accessor">-></span>value <span class="z-c z-keyword z-operator z-assignment">=</span> val<span class="z-c z-punctuation z-terminator">;</span>
  n<span class="z-c z-punctuation z-accessor">-></span>next <span class="z-c z-keyword z-operator z-assignment">=</span> list<span class="z-c z-punctuation z-accessor">-></span>head<span class="z-c z-punctuation z-terminator">;</span>
  list<span class="z-c z-punctuation z-accessor">-></span>head <span class="z-c z-keyword z-operator z-assignment">=</span> n<span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><h2 id=memory-management-of-linked-structures><a href=#memory-management-of-linked-structures aria-label="anchor link for memory-management-of-linked-structures">##</a> Memory Management of Linked Structures</h2><p>With linked structures, since we're doing dynamic allocation, you must be very careful that you don't leave anything dangling.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Freeing a list iteratively
</span><span class="z-c z-keyword z-control">while</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>head<span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  Node <span class="z-c z-keyword z-operator">*</span>next <span class="z-c z-keyword z-operator z-assignment">=</span> head<span class="z-c z-punctuation z-accessor">-></span>next<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">free</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group">head</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  head <span class="z-c z-keyword z-operator z-assignment">=</span> next<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Freeing a list recursively
</span><span class="z-c z-type z-storage">void</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">freeNode</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group">Node <span class="z-c z-keyword z-operator">*</span><span class="z-c z-variable z-parameter">n</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function"> </span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  <span class="z-c z-keyword z-control">if</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span>n<span class="z-c z-punctuation z-accessor">-></span>next<span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
    <span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">freeNode</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group">n<span class="z-c z-punctuation z-accessor">-></span>next</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-section z-end z-block">}</span></span>
  <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">free</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group">n</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><h2 id=adding-and-removing-in-linked-lists><a href=#adding-and-removing-in-linked-lists aria-label="anchor link for adding-and-removing-in-linked-lists">##</a> Adding and Removing in Linked Lists</h2><p>In Java, we had to do the really annoying special cases for removing at the front. However, because C allows us to use pointers more easily, we can get rid of that special case by "taking a step back" and using a pointer the current node we're on. We can then just mutate the thing we're pointing to.<p>You already know this and there's a great Computerphile video about it, so I won't talk to much about it.<p><a href="https://www.youtube.com/watch?v=t5NszbIerYc">https://www.youtube.com/watch?v=t5NszbIerYc</a><h1 id=advanced-object-orientation><a href=#advanced-object-orientation aria-label="anchor link for advanced-object-orientation">#</a> Advanced Object Orientation</h1><p>OOP in C is difficult, hard to read, hard to maintain, and overall not idiomatic. However, for educational purposes, it is good to see how object orientation can be / is done at a low level. We'll only talk about inheritance, constructors, destructors, methods, and single dispatch.<p>Inheritance is the hardest of these.<h2 id=inheritance><a href=#inheritance aria-label="anchor link for inheritance">##</a> Inheritance</h2><p>For inheritance, C's type system actively fights us. To make it work, we can do multiple things. We can either have our subtyped struct have an instance of the superclass struct as the first element (bad) or we could have our subtype struct declare the same fields in the same order (worse).<p>Here, we'll only cover how to do single inheritance because multiple inheritance is very difficult because you need to do address manipulation.<p>For the safe-ish method, the way you use the subtype is by casting it to the supertype. Since C will put the first field at the start of the struct, when you cast it you still have a valid address. This also means you can upcast in the future as long as you're using pointers and not passing things by value.<p>For the unsafe method, the way you use the subtype is by casting it to the supertype and hope that the you remembered to declare the fields in the correct order and the compiler left them in the same order. Otherwise its the same.<h2 id=constructors><a href=#constructors aria-label="anchor link for constructors">##</a> Constructors</h2><p>Constructors are just procedures which dynamically<h1 id=handling-binary-data><a href=#handling-binary-data aria-label="anchor link for handling-binary-data">#</a> Handling Binary Data</h1><p>Sadly, C99 has no way of reading in binary, printing out binary, or writing binary literals.<h2 id=little-big-endianness><a href=#little-big-endianness aria-label="anchor link for little-big-endianness">##</a> Little/Big Endianness</h2><p>Differ architectures use differ byte orders for memory. This is because computer engineers disagree on which is better, because there's not much of a difference.<p><strong>Little endian</strong> machines put the least significant byte first. <strong>Big endian</strong> machines put the most significant byte first; this is the way people normally write it.<pre class="z-code language-nohighlight" data-lang=nohighlight><code class=language-nohighlight data-lang=nohighlight><span class="z-plain z-text">int a = 3;
// Little Endian: 03 00 00 00
// Big Endian: 00 00 00 03
</span></code></pre><h2 id=binary-bitwise-operators><a href=#binary-bitwise-operators aria-label="anchor link for binary-bitwise-operators">##</a> Binary/Bitwise Operators</h2><p>In C, there are many operators that operate on bits. All of the binary operators have equivalent assignment operators as you'd expect.<ul><li>Bitwise OR <code>x | y</code>: <code>0b10 | 0b01</code> is <code>0b11</code>.<ul><li>Logical OR <code>||</code>.</ul><li>Bitwise AND <code>x & y</code>: <code>0b10 & 0b01</code> is <code>0b00</code>.<ul><li>Logical AND <code>&&</code>.</ul><li>Bitwise NOT <code>~x</code>: <code>~0b10</code> is <code>0b01</code>.<ul><li>Logical NOT <code>!</code>.</ul><li>Bitwise XOR <code>^x</code>: <code>0b110 ^ 0b100</code> is <code>0b010</code>.<li>Left Shift <code>x &lt;&lt; n</code>: Shifts the bits left by <code>n</code>, putting 0s in for the "walk off". <code>0b110 &lt;&lt; 1</code> is <code>0b100</code>.<li>Right Logical Shift <code>x >> n</code>: Shifts the bits right by <code>n</code>, putting 0s in for the "walk off". <code>0b011 >> 1</code> is <code>0b001</code>. Applies only to unsigned integers.<li>Right Arithmetic Shift <code>x >> n</code>: Same as right logical shift, except that the "walk off" (on the left) is replaced with the sign bit. Applies only to signed integers.</ul><figure><img src=left_shift.png><figcaption><p><code>0x1A &lt; 5</code></figcaption></figure><h2 id=bit-masking><a href=#bit-masking aria-label="anchor link for bit-masking">##</a> Bit Masking</h2><p>Sometimes, we only care about certain bits. To get at these bits, we apply a <strong>mask</strong>. A mask is just a number with specific bits flipped based off of what you care about.<p>By ANDing the mask with the bits of interest, we keep only the bits that were <code>1</code> in the original bits, making everything else <code>0</code>. This is called clearing selected bits.<pre class="z-code language-nohighlight" data-lang=nohighlight><code class=language-nohighlight data-lang=nohighlight><span class="z-plain z-text">// Clear bits 0 and 2
bits = 0b0110
mask = 0b1010
bits & mask // 0b0010
</span></code></pre><p>By ORing the mask with the bits of interest, we keep only the bits that were <code>0</code> in the original bits, making everything else <code>1</code>. This is called setting selected bits.<pre class="z-code language-nohighlight" data-lang=nohighlight><code class=language-nohighlight data-lang=nohighlight><span class="z-plain z-text">// Set bits 3 and 1
bits = 0b0110
mask = 0b1010
bits | mask // 0b1110
</span></code></pre><p>By XORing the mask with the bits of interest, we invert all the bits of interest.<pre class="z-code language-nohighlight" data-lang=nohighlight><code class=language-nohighlight data-lang=nohighlight><span class="z-plain z-text">// Invert bits 3 and 1
bits = 0b0110
mask = 0b1010
bits ^ mask // 0b1100
</span></code></pre><p>We can copy bit ranges by creating a mask of 1s with that range. We then AND the source with the mask, AND the destination with the inverse of the mask, and then OR those together.<figure><img src=copy_bits.png><figcaption><p>Copying Bits</figcaption></figure><h2 id=bit-fields-packing><a href=#bit-fields-packing aria-label="anchor link for bit-fields-packing">##</a> Bit Fields / Packing</h2><p>We can pack multiple smaller integers inside of a large integer by using masks and bit shifting for modification and access. This allows for less memory use at the cost of runtime (normally), since memory access that isn't along address boundaries is less efficient on most CPUs.<p><a href=https://elihunter173.com/notes/ncsu/2f/csc230/integer_packing.png>Integer Packing</a><p>You <em>really</em> shouldn't do this by hand if you do it at all. It's very easy to make mistakes and it makes simple operations much more tedious.<p>If you're going to do this, we can make the compiler handle this by using bit fields in structs. This makes the compiler handle all the shifting nonsense required for field access and modification. It also handles when the number of bit fields is longer than a single integer.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-type z-storage">unsigned</span> <span class="z-c z-type z-storage">short</span> red<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">unsigned</span> <span class="z-c z-type z-storage">short</span> green<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">unsigned</span> <span class="z-c z-type z-storage">char</span> blue<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">unsigned</span> <span class="z-c z-type z-storage">char</span> alpha<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">RegularColor</span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group">RegularColor</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> 6
</span>
<span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-type z-storage">unsigned</span> <span class="z-c z-type z-storage">short</span> red <span class="z-c z-keyword z-operator z-ternary">:</span> <span class="z-c z-constant z-decimal z-numeric z-integer">9</span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">unsigned</span> <span class="z-c z-type z-storage">short</span> green <span class="z-c z-keyword z-operator z-ternary">:</span> <span class="z-c z-constant z-decimal z-numeric z-integer">9</span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">unsigned</span> <span class="z-c z-type z-storage">char</span> blue <span class="z-c z-keyword z-operator z-ternary">:</span> <span class="z-c z-constant z-decimal z-numeric z-integer">6</span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">unsigned</span> <span class="z-c z-type z-storage">char</span> alpha <span class="z-c z-keyword z-operator z-ternary">:</span> <span class="z-c z-constant z-decimal z-numeric z-integer">6</span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">PackedColor</span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group">PackedColor</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> 4
</span></span></code></pre><p>In general, these act exactly like normal fields. However, you cannot access the address of the values, since they may not line up along address boundaries.<p><strong>Note:</strong> This is generally a bad idea and unnecessary on most modern systems, since memory is cheap and its not very portable.<h2 id=2-s-complement><a href=#2-s-complement aria-label="anchor link for 2-s-complement">##</a> 2's Complement</h2><p>There's a fantastic <a href="https://www.youtube.com/watch?v=PS5p9caXS4U">video</a> about this. This explains 2's complement in decimal.<p>We normally use 2's complement, rather than 1's complement. This is because 1's complement has a complicated "end around borrow" concept and a negative 0.<h1 id=object-oriented-component-design><a href=#object-oriented-component-design aria-label="anchor link for object-oriented-component-design">#</a> Object Oriented / Component Design</h1><p>Changing header files is expensive because that requires recompiling the client code and the library code. If we just change the library file, then we only need to recompile the library code, which is faster.<p>For that reason, you want your header file to be as minimal as possible, only making a library promise without exposing unnecessary implementation details. There are a few ways to do this.<h2 id=abstract-hidden-object><a href=#abstract-hidden-object aria-label="anchor link for abstract-hidden-object">##</a> Abstract/Hidden Object</h2><p>We completely hide the object in question. The library maintains a static singleton instance that isn't exposed in the header. The client can only interact with this library code using procedures which interact with this singleton instance behind the scenes. This is like project 3's wordlist!<p>This is generally <strong>okay</strong>, but it only allows us to have a single instance, so it's very <strong>inflexible</strong>.<h2 id=incomplete-type-abstract-data-type><a href=#incomplete-type-abstract-data-type aria-label="anchor link for incomplete-type-abstract-data-type">##</a> Incomplete Type / Abstract Data Type</h2><p>In the header file, we can declare that certain types/structs exist without providing any fields on them. This means that clients can know that the library provides such objects, but can't see any of their fields. In other words, these objects are <strong>opaque</strong> to the client.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Incomplete types in header
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> Node <span class="z-c z-type z-entity z-name z-typedef">Node</span><span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Specific implementations in source
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> Node <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Here we're storing any generic data using a
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> void pointer and a size
</span>  <span class="z-c z-type z-support z-sys-types">size_t</span> size<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">void</span> <span class="z-c z-keyword z-operator">*</span>data<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">struct</span> Node <span class="z-c z-keyword z-operator">*</span>next<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span>
</span></code></pre><p>This is a lot like how Java and other traditional object oriented languages work. However, they make it easier to use procedures that mutate the object by using method notation, which attaches the procedure to the namespace of a specific object. They also do a bunch of fancy single dispatch, polymorphism, inheritance, and all that jazz.<p><strong>Note:</strong> This is an excellent trade off because it doesn't make either the library or the client code more complicated, but it does make the library significantly more flexible.<h3 id=generic-abstract-data-types><a href=#generic-abstract-data-types aria-label="anchor link for generic-abstract-data-types">###</a> Generic Abstract Data Types</h3><p>Many times, we want a certain object to work with an entire family of objects. (You want containers to work with any contained data.) C has the garbage, OG way of doing this. To do this in C, you store a raw pointer and the number of bytes associated with that piece of data. Then, client code must provide the type either through function pointers that manipulate that data or using casting whenever they want to pull something out of the object.<p>Here's a complete example that is a set implemented using an unordered linked list.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-meta z-preprocessor z-include"><span class="z-c z-keyword z-control z-import z-include">#include</span> <span class="z-c z-string z-quoted z-double z-include"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>set.h<span class="z-c z-punctuation z-definition z-string z-end">"</span></span>
</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> An inner component of our actual data type,
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Set
</span><span class="z-c z-meta z-struct"><span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-struct"><span class="z-c z-entity z-name z-struct">Node</span></span></span><span class="z-c z-meta z-struct"> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block">
  <span class="z-c z-type z-storage">void</span> <span class="z-c z-keyword z-operator">*</span>val<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-meta z-struct"><span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-struct"><span class="z-c z-entity z-name z-struct">Node</span></span></span><span class="z-c z-meta z-struct"> *next</span><span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">bool</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-variable">eq_fn</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-type z-storage">void</span> <span class="z-c z-storage z-modifier">const</span> <span class="z-c z-keyword z-operator">*</span>v1<span class="z-c z-punctuation z-separator">,</span>
                   <span class="z-c z-type z-storage">void</span> <span class="z-c z-storage z-modifier">const</span> <span class="z-c z-keyword z-operator">*</span>v2</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> This is our actual data type this file deals
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> with
</span><span class="z-c z-type z-storage">typedef</span> <span class="z-c z-type z-storage">struct</span> SetStruct <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> I can store any data, but I must know their
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> size and how to compare the data
</span>  <span class="z-c z-type z-support z-sys-types">size_t</span> vsize<span class="z-c z-punctuation z-terminator">;</span>
  eq_fn same<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">struct</span> Node <span class="z-c z-keyword z-operator">*</span>head<span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-punctuation z-section z-end z-block">}</span></span> <span class="z-c z-type z-entity z-name z-typedef">Set</span><span class="z-c z-punctuation z-terminator">;</span>

Set <span class="z-c z-keyword z-operator">*</span><span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">makeSet</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-type z-support z-sys-types">size_t</span> <span class="z-c z-variable z-parameter">vsize</span><span class="z-c z-punctuation z-separator">,</span> eq_fn <span class="z-c z-variable z-parameter">same</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function"> </span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  Set <span class="z-c z-keyword z-operator">*</span>s <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">malloc</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-keyword z-operator z-word">sizeof</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span><span class="z-c z-meta z-group">Set</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span> <span class="z-c z-punctuation z-terminator">;</span>
  s<span class="z-c z-punctuation z-accessor">-></span>head <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-language">NULL</span><span class="z-c z-punctuation z-terminator">;</span>
  s<span class="z-c z-punctuation z-accessor">-></span>vsize <span class="z-c z-keyword z-operator z-assignment">=</span> vsize<span class="z-c z-punctuation z-terminator">;</span>
  s<span class="z-c z-punctuation z-accessor">-></span>same <span class="z-c z-keyword z-operator z-assignment">=</span> same<span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-control z-flow z-return">return</span> s<span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><p><strong>Note:</strong> This makes both the library and the client code more complicated with the benefit that it makes the library more flexible. This is generally seen as a reasonable fair trade off as it doesn't make the client code significantly more complicated, although it does make the library code significantly more complicated.<h1 id=security-safety><a href=#security-safety aria-label="anchor link for security-safety">#</a> Security & Safety</h1><p>C has no training wheels. This makes it very powerful and efficient. However, it also makes it easy to introduce <strong>bugs</strong> and <strong>security exploits</strong>.<h2 id=resource-leak><a href=#resource-leak aria-label="anchor link for resource-leak">##</a> Resource Leak</h2><p>If you <code>malloc</code> something and return it in one path but not another, make sure that you <code>free</code> it in the other path.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-block"><span class="z-c z-punctuation z-definition z-comment">/*</span>*
  Read an entire block of data from fp.
  @return Pointer to the block on success, or
  NULL on failure
<span class="z-c z-punctuation z-definition z-comment">*/</span></span>
<span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">getBlock</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"> FILE <span class="z-c z-keyword z-operator">*</span><span class="z-c z-variable z-parameter">fp</span> <span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function"> </span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  <span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span>buf <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-punctuation z-section z-group z-end">)</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">malloc</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"> BLOCK_SZ </span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-control">if</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span><span class="z-c z-keyword z-operator z-arithmetic">!</span>buf<span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
    <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Don't need to friend here.
</span>    <span class="z-c z-keyword z-control z-flow z-return">return</span> <span class="z-c z-constant z-language">NULL</span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-section z-end z-block">}</span></span>
  <span class="z-c z-keyword z-control">if</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">fread</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"> buf<span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-separator">,</span> BLOCK_SZ<span class="z-c z-punctuation z-separator">,</span> fp </span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span>
       <span class="z-c z-keyword z-operator z-comparison">!=</span> BLOCK_SZ <span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
    <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">free</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group">buf</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> MAKE SURE TO FREE HERE!!!
</span>    <span class="z-c z-keyword z-control z-flow z-return">return</span> <span class="z-c z-constant z-language">NULL</span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-section z-end z-block">}</span></span>
  <span class="z-c z-keyword z-control z-flow z-return">return</span> buf<span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><p>Likewise with file pointers.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-type z-storage">bool</span> <span class="z-c z-meta z-function"><span class="z-c z-function z-entity z-name">getFile</span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function z-parameters"><span class="z-c z-meta z-group"> <span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-variable z-parameter">name</span><span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-type z-storage">int</span> <span class="z-c z-variable z-parameter">cap</span><span class="z-c z-punctuation z-separator">,</span>
              <span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c z-variable z-parameter">buffer</span> <span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-meta z-function"> </span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block">
  FILE <span class="z-c z-keyword z-operator">*</span>fp <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">fopen</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"> name<span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>r<span class="z-c z-punctuation z-definition z-string z-end">"</span></span> </span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-keyword z-control">if</span> <span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span> <span class="z-c z-keyword z-operator z-arithmetic">!</span>fp <span class="z-c z-punctuation z-section z-group z-end">)</span></span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span>
    <span class="z-c z-keyword z-control z-flow z-return">return</span> <span class="z-c z-constant z-language">false</span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-punctuation z-section z-end z-block">}</span></span>
  <span class="z-c z-type z-storage">int</span> len <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">fread</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"> buffer<span class="z-c z-punctuation z-separator">,</span> <span class="z-c z-constant z-decimal z-numeric z-integer">1</span><span class="z-c z-punctuation z-separator">,</span> cap<span class="z-c z-punctuation z-separator">,</span> fp </span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-meta z-function-call"><span class="z-c z-function z-C99 z-support">fclose</span><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-begin">(</span></span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group">fp</span></span><span class="z-c z-meta z-function-call"><span class="z-c z-meta z-group"><span class="z-c z-punctuation z-section z-group z-end">)</span></span></span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> MAKE SURE NOT TO FORGET HERE
</span>  <span class="z-c z-keyword z-control z-flow z-return">return</span> len <span class="z-c z-keyword z-operator z-comparison">></span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-function"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><h2 id=input-validation><a href=#input-validation aria-label="anchor link for input-validation">##</a> Input Validation</h2><p>When you do input validation, it's better to <strong>whitelist</strong> rather than <strong>blacklist</strong>. Also, should you try to avoid taking in user input and pasting that into some sort of "eval" function.<p>The best way to validate inputs is by using an open-source library that validates and escapes things <strong>immediately</strong>.<p>C has a <code>int system(const char*)</code> procedure, that allows us to just run the given string as if it were a shell command, and returns its return code. You should <strong>never use this</strong> because it's slow and insecure. If you use it, make sure to <strong>completely</strong> and <strong>totally</strong> validate all input.<h1 id=enums><a href=#enums aria-label="anchor link for enums">#</a> Enums</h1><p>C enums allow us to avoid using preprocessor macros. This lets us have more sophisticated scope rules.<p>C also automatically determines the optimal integer type for the enum in terms of size and speed.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Simple enum
</span><span class="z-c z-meta z-enum"><span class="z-c z-type z-storage">enum</span> <span class="z-c z-meta z-enum"><span class="z-c z-entity z-name z-enum">Color</span></span></span><span class="z-c z-meta z-enum"> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block"> RED<span class="z-c z-punctuation z-separator">,</span> GREEN<span class="z-c z-punctuation z-separator">,</span> BLUE </span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-type z-storage">enum</span> Color c <span class="z-c z-keyword z-operator z-assignment">=</span> RED<span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Enum with specified values
</span><span class="z-c z-meta z-enum"><span class="z-c z-type z-storage">enum</span> <span class="z-c z-meta z-enum"><span class="z-c z-entity z-name z-enum">Mood</span></span></span><span class="z-c z-meta z-enum"> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block">
  HAPPY <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">2</span><span class="z-c z-punctuation z-separator">,</span>
  AFRAID<span class="z-c z-punctuation z-separator">,</span>
  BORED <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">0</span><span class="z-c z-punctuation z-separator">,</span>
  BLUE<span class="z-c z-punctuation z-separator">,</span>
  GLAD<span class="z-c z-punctuation z-separator">,</span>
</span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
<span class="z-c z-type z-storage">enum</span> Mood m <span class="z-c z-keyword z-operator z-assignment">=</span> HAPPY<span class="z-c z-punctuation z-terminator">;</span>
</span></code></pre><p>There are a few limits on enums. You can't have two enums in the same scope with the same value. Also, enums are literally just integers, so you can add them, use them as booleans, increment them, and all that nonsense. They are also printed as integers.<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-meta z-enum"><span class="z-c z-type z-storage">enum</span> <span class="z-c z-meta z-enum"><span class="z-c z-entity z-name z-enum">Color</span></span></span><span class="z-c z-meta z-enum"> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block"> red<span class="z-c z-punctuation z-separator">,</span> green<span class="z-c z-punctuation z-separator">,</span> blue </span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
 <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> This won't work because `blue` is reused.
</span><span class="z-c z-meta z-enum"><span class="z-c z-type z-storage">enum</span> <span class="z-c z-meta z-enum"><span class="z-c z-entity z-name z-enum">Mood</span></span></span><span class="z-c z-meta z-enum"> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block"> happy<span class="z-c z-punctuation z-separator">,</span> sad<span class="z-c z-punctuation z-separator">,</span> blue </span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-type z-storage">enum</span> Mood m <span class="z-c z-keyword z-operator z-assignment">=</span> happy<span class="z-c z-punctuation z-terminator">;</span>
m<span class="z-c z-keyword z-operator z-arithmetic">++</span><span class="z-c z-punctuation z-terminator">;</span> <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> m == sad
</span></span></code></pre><h2 id=enum-hack><a href=#enum-hack aria-label="anchor link for enum-hack">##</a> Enum Hack</h2><p>Since enums are constant expressions and respect scope, we can use them as compile time constants if we're using a common name (e.g. <code>SIZE</code>).<pre class="language-c z-code" data-lang=c><code class=language-c data-lang=c><span class="z-c z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Okay, but doesn't respect scope
</span><span class="z-c z-meta z-preprocessor z-macro"><span class="z-c z-keyword z-control z-import z-define">#define</span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-constant z-entity z-name z-preprocessor">SIZE</span></span><span class="z-c z-meta z-preprocessor z-macro"> <span class="z-c z-constant z-decimal z-numeric z-integer">100</span></span>
<span class="z-c z-meta z-struct"><span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-struct"><span class="z-c z-entity z-name z-struct">Contact</span></span></span><span class="z-c z-meta z-struct"> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block">
  <span class="z-c z-type z-storage">char</span> name<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span> SIZE <span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">char</span> email<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span> SIZE <span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span><span class="z-c z-punctuation z-terminator">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Does respect scope, but a little hacky
</span><span class="z-c z-meta z-struct"><span class="z-c z-type z-storage">struct</span> <span class="z-c z-meta z-struct"><span class="z-c z-entity z-name z-struct">Contact</span></span></span><span class="z-c z-meta z-struct"> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block">
  <span class="z-c z-meta z-enum"><span class="z-c z-type z-storage">enum</span> <span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-begin z-block">{</span></span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block"> SIZE <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-decimal z-numeric z-integer">100</span> </span></span><span class="z-c z-meta z-enum"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">char</span> name<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span> SIZE <span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
  <span class="z-c z-type z-storage">char</span> email<span class="z-c z-meta z-brackets"><span class="z-c z-punctuation z-section z-begin z-brackets">[</span> SIZE <span class="z-c z-punctuation z-section z-end z-brackets">]</span></span><span class="z-c z-punctuation z-terminator">;</span>
</span></span><span class="z-c z-meta z-struct"><span class="z-c z-meta z-block"><span class="z-c z-punctuation z-section z-end z-block">}</span></span></span>
</span></code></pre><h1 id=unions><a href=#unions aria-label="anchor link for unions">#</a> Unions</h1><h1 id=odd-keywords><a href=#odd-keywords aria-label="anchor link for odd-keywords">#</a> Odd Keywords</h1><p>C normally makes optimizations such as storing values to the register and not rereading memory. This is good because it's more performant. However, sometimes (e.g. when doing concurrency), that value might have changed. We use the <code>volatile</code> keyword to tell C to not do optimizations for this value.<h1 id=testing-profiling><a href=#testing-profiling aria-label="anchor link for testing-profiling">#</a> Testing & Profiling</h1><p>Profiling is the process of figuring out what your program is spending its time and resources doing. You know what testing and coverage is.<h2 id=test-coverage><a href=#test-coverage aria-label="anchor link for test-coverage">##</a> Test Coverage</h2><p>In this class, we use <code>gcov</code> (GNU Coverage tool) to get test coverage. This requires we enable some features on compilation. <code>-fprofile-arcs</code> tracks branch coverage. <code>-ftest-coverage</code> tracks statement coverage.<h2 id=profiling><a href=#profiling aria-label="anchor link for profiling">##</a> Profiling</h2><p>In this class, we use <code>gprof</code> (GNU Profiler tool) to profile things.<h2 id=diy-optimizations><a href=#diy-optimizations aria-label="anchor link for diy-optimizations">##</a> DIY Optimizations</h2><p>Generally, you should not do these DIY code optimizations if they hurt readability. Most compilers are optimizing and will do this for you. A few exceptions are inlining simple functions, passing by <code>const</code> reference, and putting the most common conditions first.<h1 id=c><a href=#c aria-label="anchor link for c">#</a> C++</h1><p>We'll learning C++11. It has the following features.<ul><li>Namespaces<li>Classes and objects.<li>Destructors.<li>Operate overloading.<li>Move Semantics: How to safely describe memory changes / ownership.<li><code>constexpr</code>: Evaluate arbitrary expressions at compile time.<li>Range Based For Loops: Iterators.<li>Lambda Expressions.<li>Lambda Captures: Strongly documented closures.<li><code>nullptr</code>: Essentially renamed <code>NULL</code>.<li>Templates: Allows you to define how to build a function given some arbitrary compile time values. Created for compile time generics.<ul><li>Can be used for <em>many</em> other things.</ul><li>C backwards compatibility.</ul><p>Here's an overview of the terminology that differs from Java's terminology.<ul><li>Base Class: Super(most) class.<li>Derived Class: Subclass.</ul><h2 id=hello-world><a href=#hello-world aria-label="anchor link for hello-world">##</a> Hello World!</h2><p>Notice how we use the bitshift operators? That's standard in C++! We overload the stream with nice-looking operators to give use new, easier syntax.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> So we get access to std::cout
</span><span class="z-meta z-c++ z-include z-preprocessor"><span class="z-c++ z-keyword z-control z-import z-include">#include</span> <span class="z-c++ z-other z-include z-lt-gt z-quoted z-string"><span class="z-punctuation z-begin z-c++ z-definition z-string">&lt;</span>iostream<span class="z-punctuation z-end z-c++ z-definition z-string">></span></span>
</span>
<span class="z-c z-type z-storage">int</span> <span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">main</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Put the folowing string to the std::cout
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> stream. std::cout is buffered stdout.
</span>  std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Hello, World!<span class="z-c z-constant z-character z-escape">\n</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-punctuation z-terminator z-c++">;</span>

  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Alternatively, use std::endl, the platform
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> specific line terminator.
</span>  std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>count <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Hello, World!<span class="z-c z-punctuation z-definition z-string z-end">"</span></span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>endl<span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> std::flush tells the buffered output to
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> flush manually.
</span>  std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>count <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Hello, World!<span class="z-c z-punctuation z-definition z-string z-end">"</span></span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-single"><span class="z-c z-punctuation z-definition z-string z-begin">'</span><span class="z-c z-constant z-character z-escape">\n</span><span class="z-c z-punctuation z-definition z-string z-end">'</span></span>
    <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>flush<span class="z-punctuation z-terminator z-c++">;</span>

  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Generally, you shouldn't use std::endl or
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> std::flush because generally the OS knows
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> better when it should flush the buffer than
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> you.
</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span></code></pre><h2 id=namespaces><a href=#namespaces aria-label="anchor link for namespaces">##</a> Namespaces</h2><p>Namespace extensions<p>C++ defaults to searching in the current namespace (including any namespaces you're <code>using</code>). If it can't find the name you're looking for, then that's an error.<p>C++ has the scope resolution operation: <code>::</code>. You put this after a namespace to get a name within the namespace.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-type z-storage">int</span> val <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">3</span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c z-type z-storage">void</span> <span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">f</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Prints 3
</span>  std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> val<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>

<span class="z-meta z-c++ z-namespace"><span class="z-c++ z-keyword z-control">namespace</span> </span><span class="z-meta z-c++ z-namespace"><span class="z-c++ z-entity z-name z-namespace">MyNamespace</span></span><span class="z-meta z-c++ z-namespace"> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
  <span class="z-c z-type z-storage">int</span> val <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator z-arithmetic">-</span><span class="z-c++ z-constant z-decimal z-integer z-numeric">10</span><span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-c z-type z-storage">void</span> <span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">f</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
    std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>val: <span class="z-c z-punctuation z-definition z-string z-end">"</span></span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> val <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-character z-escape">\n</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-punctuation z-terminator z-c++">;</span>
    std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>global: <span class="z-c z-punctuation z-definition z-string z-end">"</span></span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>val <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span><span class="z-c z-constant z-character z-escape">\n</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-punctuation z-terminator z-c++">;</span>
  </span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> ...
</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Call global f
</span><span class="z-meta z-c++ z-function-call"><span class="z-c++ z-function z-variable">f</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function-call"></span><span class="z-meta z-c++ z-function-call"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Call f in MyNamespace
</span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list">MyNamespace<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span><span class="z-c++ z-function z-entity z-name z-constructor">f</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><h2 id=using-c-libraries><a href=#using-c-libraries aria-label="anchor link for using-c-libraries">##</a> Using C Libraries</h2><p>We can use C libraries easily in C++. The only difference is that they are in the <code>std</code> namespace and their header files get a makeover. Remove the <code>.h</code> and prepend the name with a <code>c</code>. We use namespaces because they're nice.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Import stdio.h from C
</span><span class="z-meta z-c++ z-include z-preprocessor"><span class="z-c++ z-keyword z-control z-import z-include">#include</span> <span class="z-c++ z-other z-include z-lt-gt z-quoted z-string"><span class="z-punctuation z-begin z-c++ z-definition z-string">&lt;</span>cstdio<span class="z-punctuation z-end z-c++ z-definition z-string">></span></span>
</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Like a * import from other languages. Import
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> everything from std namespace into our
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> namespace. Use with care! (Or not at all.)
</span><span class="z-c++ z-keyword z-control">using</span> <span class="z-c++ z-keyword z-control">namespace</span> std<span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-c z-type z-storage">int</span> <span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">main</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
  <span class="z-meta z-c++ z-function-call"><span class="z-c z-function z-C99 z-support">printf</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function-call"><span class="z-meta z-c++ z-group"><span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Hello, within C!<span class="z-c z-constant z-character z-escape">\n</span><span class="z-c z-punctuation z-definition z-string z-end">"</span></span></span></span><span class="z-meta z-c++ z-function-call"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span></code></pre><h2 id=file-io-1><a href=#file-io-1 aria-label="anchor link for file-io-1">##</a> File IO</h2><p>File IO is done using input streams (<code>istream</code>s) and output streams (<code>ostream</code>s). Specifically, it's done with a specialization of both of these streams, <code>fstream</code>s.<h2 id=raii-resource-acquisition-is-initialization><a href=#raii-resource-acquisition-is-initialization aria-label="anchor link for raii-resource-acquisition-is-initialization">##</a> RAII (Resource Acquisition Is Initialization)</h2><p>RAII is a standard idiom in programming. It essentially says that all resources should have a constructor and destructor. The constructor is called at resource acquisition time. C++ itself automatically calls the destructor whenever your object goes out of scope. It guarantees that it calls this in all possible paths, even if your program crashes. You <em>can</em> manually call the destructor.<p>This is sometimes called SBRM (Scope Based Resource Management). It's the same thing.<p>This pattern means we don't need to worry about a lot of resources. For example, we don't <em>need</em> to close files when we're done with them. (Although it's not a bad idea.)<h2 id=references-and-move-semantics><a href=#references-and-move-semantics aria-label="anchor link for references-and-move-semantics">##</a> References and Move Semantics</h2><p>References are a safe abstraction around pointers that allows for additional optimizations, because we're guaranteed by the compiler the pointers are known to be identical.<p>Syntactically, we treat it as if we had the value itself. Essentially, it's just an <em>alias</em> for the other value. This means we can also <em>assign to returned references</em>, which is really cool.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Takes a reference to a and b
</span><span class="z-c z-type z-storage">void</span> <span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">swap</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">&</span><span class="z-c++ z-variable z-parameter">a</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">&</span><span class="z-c++ z-variable z-parameter">b</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> notice how we're not dereferencing. It
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> calls int's copy constructor
</span>  <span class="z-c z-type z-storage">int</span> tmp <span class="z-c z-keyword z-operator z-assignment">=</span> a<span class="z-punctuation z-terminator z-c++">;</span>
  a <span class="z-c z-keyword z-operator z-assignment">=</span> b<span class="z-punctuation z-terminator z-c++">;</span>
  b <span class="z-c z-keyword z-operator z-assignment">=</span> temp<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span></code></pre><pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-type z-storage">int</span> <span class="z-c++ z-keyword z-operator">&</span>a <span class="z-c z-keyword z-operator z-assignment">=</span> some<span class="z-meta z-c++ z-brackets"><span class="z-punctuation z-section z-begin z-c++ z-brackets">[</span>complicated<span class="z-punctuation z-section z-end z-c++ z-brackets">]</span></span><span class="z-punctuation z-accessor z-c++ z-arrow">-></span><span class="z-c++ z-variable z-member z-other z-readwrite">object</span><span class="z-punctuation z-accessor z-c++ z-dot">.</span><span class="z-c++ z-variable z-member z-other z-readwrite">thing</span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> ...
</span>cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> a <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>endl<span class="z-punctuation z-terminator z-c++">;</span>
a <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">12</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-type z-storage">int</span> <span class="z-c++ z-keyword z-operator">&</span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">lookup</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"> <span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c++ z-variable z-parameter">name</span> <span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
  <span class="z-c z-keyword z-operator z-variadic">...</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> ...
</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Assigning from reference
</span><span class="z-c z-type z-storage">int</span> x <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-meta z-c++ z-function-call"><span class="z-c++ z-function z-variable">lookup</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function-call"><span class="z-meta z-c++ z-group"> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>mary<span class="z-c z-punctuation z-definition z-string z-end">"</span></span> </span></span><span class="z-meta z-c++ z-function-call"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Assigning to reference
</span><span class="z-meta z-c++ z-function-call"><span class="z-c++ z-function z-variable">lookup</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function-call"><span class="z-meta z-c++ z-group"> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>bob<span class="z-c z-punctuation z-definition z-string z-end">"</span></span> </span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span> <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">35</span><span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Notice how there's no pointer syntax!
</span></span></code></pre><h2 id=templates><a href=#templates aria-label="anchor link for templates">##</a> Templates</h2><p>We want to define our functions to work with abstract data. How do we do that? In C++, we use templates!<p>Templates are compile time feature, where the compiler figures out all the different versions of your template you call and compile them all as separate functions.<h2 id=default-parameters><a href=#default-parameters aria-label="anchor link for default-parameters">##</a> Default Parameters</h2><p>The syntax is almost exactly what you think it would be!<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-type z-storage">void</span> <span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">repeat</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-c z-type z-storage">char</span> <span class="z-c++ z-storage z-modifier">const</span> <span class="z-c z-keyword z-operator">*</span><span class="z-c++ z-variable z-parameter">str</span> <span class="z-c++ z-keyword z-operator z-assignment">=</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Good Evening<span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-punctuation z-separator z-c++">,</span>
            <span class="z-c z-type z-storage">int</span> <span class="z-c++ z-variable z-parameter">count</span> <span class="z-c++ z-keyword z-operator z-assignment">=</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">10</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
  <span class="z-c++ z-keyword z-control">for</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-c z-type z-storage">int</span> i <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">0</span><span class="z-punctuation z-terminator z-c++">;</span> i <span class="z-c z-keyword z-operator z-comparison">&lt;</span> count<span class="z-punctuation z-terminator z-c++">;</span> i<span class="z-c z-keyword z-operator z-arithmetic">++</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
    std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> str<span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
</span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span></code></pre><h2 id=string-class><a href=#string-class aria-label="anchor link for string-class">##</a> String Class</h2><p>Strings are mutable character buffers wrapped in objects. You can treat them like primitives and they use copy semantics.<p>They also have array indexing overloaded, so you can treat them like char arrays!<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source">string a <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>123<span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-punctuation z-terminator z-c++">;</span>
string b <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>xyz<span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-punctuation z-terminator z-c++">;</span>
string c<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> copies a to c
</span>c <span class="z-c z-keyword z-operator z-assignment">=</span> a<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> makes c a copy of a and b concatenated
</span>c <span class="z-c z-keyword z-operator z-assignment">=</span> a <span class="z-c z-keyword z-operator z-arithmetic">+</span> b<span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Compares the contents of a and b
</span><span class="z-c++ z-keyword z-control">if</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span>a <span class="z-c z-keyword z-operator z-comparison">==</span> b<span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
  cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Hi!<span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
</span></code></pre><h3 id=string-io><a href=#string-io aria-label="anchor link for string-io">###</a> String IO</h3><p>You can use streams (as earlier), but there's also a few helpful functions.<ul><li><code>getline(istream &is, string &str)</code>: Reads a line from <code>is</code> into <code>str</code>, dynamically resizing <code>str</code> as necessary.</ul><h3 id=string-methods><a href=#string-methods aria-label="anchor link for string-methods">###</a> String Methods</h3><ul><li><code>string substr(int pos, int len)</code>: Create a substring of len characters, starting at pos by copying the characters.<li><code>size_t find(string &str)</code>: Return starting index of the first occurrence of str. Returns <code>string::npos</code> if no matches are found.<li><code>insert(int pos, string &str)</code>: Insert str at position pos, displacing all characters on the right.<li><code>erase(int pos, int len)</code>: Remove len characters starting at pos, shifting all characters on the right.<li><code>char *c_str()</code>: Return the underlying char array for the <code>string</code>.</ul><h2 id=standard-template-library-stl><a href=#standard-template-library-stl aria-label="anchor link for standard-template-library-stl">##</a> Standard Template Library (STL)</h2><p>The standard template library in C++ is the standard library's collection framework. It's pretty big, so we won't cover them all.<h3 id=vector><a href=#vector aria-label="anchor link for vector">###</a> Vector</h3><p>Vector is the simplest and most used container. It is in the <code>&lt;vector></code> header. It is like an <code>ArrayList</code> in Java, a resizable array of generic elements.<p>You can use the following to initialize vectors.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source">vector<span class="z-punctuation z-section z-begin z-c++ z-generic">&lt;</span><span class="z-c z-type z-storage">int</span><span class="z-punctuation z-section z-end z-c++ z-generic">></span> <span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">iList</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"> <span class="z-c++ z-constant z-decimal z-integer z-numeric">10</span> <span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
vector<span class="z-punctuation z-section z-begin z-c++ z-generic">&lt;</span><span class="z-c z-type z-storage">short</span><span class="z-punctuation z-section z-end z-c++ z-generic">></span> <span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">sList</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"> <span class="z-c++ z-constant z-decimal z-integer z-numeric">20</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-c z-keyword z-operator z-arithmetic">-</span><span class="z-c++ z-constant z-decimal z-integer z-numeric">1</span> <span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><p>Vectors have the traditional mutation methods<p>Vectors support deep copying, just use simple a assignment.<h3 id=iterators><a href=#iterators aria-label="anchor link for iterators">###</a> Iterators</h3><p>C++11 has a for each loop.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Value iteration. Generally lame.
</span><span class="z-c++ z-keyword z-control">for</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-c z-type z-storage">int</span> v <span class="z-c z-keyword z-operator z-ternary">:</span> container<span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
  count <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> v <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> endl<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Reference iteration. Only do if you need
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> mutability.
</span><span class="z-c++ z-keyword z-control">for</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">&</span>v <span class="z-c z-keyword z-operator z-ternary">:</span> container<span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
  count <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> v <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> endl<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Const reference iteration. Use most of the
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> time.
</span><span class="z-c++ z-keyword z-control">for</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-c++ z-storage z-modifier">const</span> <span class="z-c z-type z-storage">int</span> <span class="z-c z-keyword z-operator">&</span>v <span class="z-c z-keyword z-operator z-ternary">:</span> container<span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
  count <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> v <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> endl<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
</span></code></pre><h2 id=memory-management-1><a href=#memory-management-1 aria-label="anchor link for memory-management-1">##</a> Memory Management</h2><p>Like the <code>malloc</code> and <code>free</code> procedures in C, we have <code>new</code> and <code>delete</code> in C++.<h2 id=classes-and-structs><a href=#classes-and-structs aria-label="anchor link for classes-and-structs">##</a> Classes and Structs</h2><p>In C++, classes and structs are identical except that for classes, the default access is private, structs, the default access is public. Generally, however, we use structs just to be blobs of data and classes for, well, classes.<p>C++ has a lot of energy dedicated to making classes good. Here are a bunch of <em>special member functions</em>.<h3 id=constructors-1><a href=#constructors-1 aria-label="anchor link for constructors-1">###</a> Constructors</h3><p>They are responsible to assigning values to the fields to the class. The memory for the object is already allocated by the time it runs.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-meta z-c++ z-class"><span class="z-c++ z-storage z-type">class</span> </span><span class="z-meta z-c++ z-class"><span class="z-c++ z-class z-entity z-name">Person</span></span><span class="z-meta z-c++ z-class"> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block">
  string name<span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-c z-type z-storage">int</span> age<span class="z-punctuation z-terminator z-c++">;</span>

  <span class="z-c++ z-storage z-modifier">public</span><span class="z-punctuation z-section z-class z-c++">:</span>
  <span class="z-meta z-c++ z-method z-constructor"><span class="z-c++ z-function z-entity z-name z-constructor">Person</span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group">string <span class="z-c++ z-variable z-parameter">name</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-c z-type z-storage">int</span> <span class="z-c++ z-variable z-parameter">age</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-method"> </span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block">
    <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Use the implicit this reference
</span>    <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> (generally preferred)
</span>    <span class="z-c++ z-variable z-language">this</span><span class="z-punctuation z-accessor z-c++ z-arrow">-></span><span class="z-c++ z-variable z-member z-other z-readwrite">name</span> <span class="z-c z-keyword z-operator z-assignment">=</span> name<span class="z-punctuation z-terminator z-c++">;</span>
    <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Use the scope resolution operator
</span>    Person<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>age <span class="z-c z-keyword z-operator z-assignment">=</span> age<span class="z-punctuation z-terminator z-c++">;</span>
  </span></span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>

  <span class="z-c z-keyword z-operator z-variadic">...</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><h3 id=default-constructor><a href=#default-constructor aria-label="anchor link for default-constructor">###</a> Default Constructor</h3><p>The default constructor is a parameterless constructor that gets call automatically when you allocate the object. This is important to assign the fields to their start / null values.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-meta z-c++ z-class"><span class="z-c++ z-storage z-type">class</span> </span><span class="z-meta z-c++ z-class"><span class="z-c++ z-class z-entity z-name">SomeClass</span></span><span class="z-meta z-c++ z-class"> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block">
<span class="z-c++ z-storage z-modifier">public</span><span class="z-punctuation z-section z-class z-c++">:</span>
  <span class="z-meta z-c++ z-method z-constructor"><span class="z-c++ z-function z-entity z-name z-constructor">SomeClass</span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-method"> </span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block">
    std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Hi!<span class="z-c z-punctuation z-definition z-string z-end">"</span></span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> std<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>endl<span class="z-punctuation z-terminator z-c++">;</span>
  </span></span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> calls default constructor
</span>SomeClass c<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> calls default constructor
</span>SomeClass <span class="z-c++ z-keyword z-operator">*</span>cp <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c++ z-keyword z-control">new</span> SomeClass<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> calls default constructor 5 times
</span>SomeClass c<span class="z-meta z-c++ z-brackets"><span class="z-punctuation z-section z-begin z-c++ z-brackets">[</span><span class="z-c++ z-constant z-decimal z-integer z-numeric">5</span><span class="z-punctuation z-section z-end z-c++ z-brackets">]</span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><h3 id=copy-constructor><a href=#copy-constructor aria-label="anchor link for copy-constructor">###</a> Copy Constructor</h3><p>The copy constructor is used whenever you pass an object by value (whether passing it to a function or assigning it to something else).<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-meta z-c++ z-class"><span class="z-c++ z-storage z-type">class</span> </span><span class="z-meta z-c++ z-class"><span class="z-c++ z-class z-entity z-name">List</span></span><span class="z-meta z-c++ z-class"> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block">
<span class="z-c++ z-storage z-modifier">public</span><span class="z-punctuation z-section z-class z-c++">:</span>
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> other is what you want to copy. This must
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> be a reference because otherwise you'd have
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> to call the copy constructor to call the
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> copy constructor.
</span>  <span class="z-meta z-c++ z-method z-constructor"><span class="z-c++ z-function z-entity z-name z-constructor">List</span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-c++ z-storage z-modifier">const</span> List <span class="z-c z-keyword z-operator">&</span><span class="z-c++ z-variable z-parameter">other</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-method"> </span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block">
    Node <span class="z-c z-keyword z-operator">*</span><span class="z-c z-keyword z-operator">*</span>ptr <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span>head<span class="z-punctuation z-terminator z-c++">;</span>
    <span class="z-c++ z-keyword z-control">for</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span>Node <span class="z-c z-keyword z-operator">*</span>n <span class="z-c z-keyword z-operator z-assignment">=</span> other<span class="z-punctuation z-accessor z-c++ z-dot">.</span><span class="z-c++ z-variable z-member z-other z-readwrite">head</span><span class="z-punctuation z-terminator z-c++">;</span> n<span class="z-punctuation z-terminator z-c++">;</span> n <span class="z-c z-keyword z-operator z-assignment">=</span> n<span class="z-punctuation z-accessor z-c++ z-arrow">-></span><span class="z-c++ z-variable z-member z-other z-readwrite">next</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
      <span class="z-c z-keyword z-operator">*</span>ptr <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c++ z-keyword z-control">new</span> Node<span class="z-punctuation z-terminator z-c++">;</span>
      <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-c z-keyword z-operator">*</span>ptr<span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-accessor z-c++ z-arrow">-></span><span class="z-c++ z-variable z-member z-other z-readwrite">val</span> <span class="z-c z-keyword z-operator z-assignment">=</span> n<span class="z-punctuation z-accessor z-c++ z-arrow">-></span><span class="z-c++ z-variable z-member z-other z-readwrite">val</span><span class="z-punctuation z-terminator z-c++">;</span>
      ptr <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-keyword z-operator">&</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span><span class="z-c z-keyword z-operator">*</span>ptr<span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-accessor z-c++ z-arrow">-></span><span class="z-c++ z-variable z-member z-other z-readwrite">next</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span><span class="z-punctuation z-terminator z-c++">;</span>
    <span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
    <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> terminate the list
</span>    <span class="z-c z-keyword z-operator">*</span>ptr <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-language">NULL</span><span class="z-punctuation z-terminator z-c++">;</span>
  </span></span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Example usage
</span>List alist<span class="z-punctuation z-terminator z-c++">;</span>
alist<span class="z-punctuation z-accessor z-c++ z-dot">.</span><span class="z-meta z-c++ z-method-call"><span class="z-c++ z-function z-variable z-member">push</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-method-call"><span class="z-meta z-c++ z-group"><span class="z-c++ z-constant z-decimal z-integer z-numeric">2</span></span></span><span class="z-meta z-c++ z-method-call"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Calls copy constructor
</span>List blist <span class="z-c z-keyword z-operator z-assignment">=</span> alist<span class="z-punctuation z-terminator z-c++">;</span>
alist<span class="z-punctuation z-accessor z-c++ z-dot">.</span><span class="z-meta z-c++ z-method-call"><span class="z-c++ z-function z-variable z-member">push</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-method-call"><span class="z-meta z-c++ z-group"><span class="z-c++ z-constant z-decimal z-integer z-numeric">3</span></span></span><span class="z-meta z-c++ z-method-call"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
alist<span class="z-punctuation z-accessor z-c++ z-dot">.</span><span class="z-meta z-c++ z-method-call"><span class="z-c++ z-function z-variable z-member">size</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-method-call"></span><span class="z-meta z-c++ z-method-call"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span> <span class="z-c z-keyword z-operator z-comparison">==</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">2</span><span class="z-punctuation z-terminator z-c++">;</span>
blist<span class="z-punctuation z-accessor z-c++ z-dot">.</span><span class="z-meta z-c++ z-method-call"><span class="z-c++ z-function z-variable z-member">size</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-method-call"></span><span class="z-meta z-c++ z-method-call"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span> <span class="z-c z-keyword z-operator z-comparison">==</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">3</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre><h3 id=destructor><a href=#destructor aria-label="anchor link for destructor">###</a> Destructor</h3><p>Destructors are called automatically when the object goes out of scope (allocated on the stack) or when <code>delete</code> is called manually. C++ will default to having a destructor that does nothing. This is <strong>not</strong> okay for objects that dynamically allocate things.<h3 id=operator-overloading><a href=#operator-overloading aria-label="anchor link for operator-overloading">###</a> Operator Overloading</h3><p>All operator's are overloaded by defining a <code>operatorSYMBOL</code> member function. They only must accept a certain number of arguments, but their types are returns are not mandated.<p>They can be member functions or not.<h3 id=suppressing-value-semantics-and-others><a href=#suppressing-value-semantics-and-others aria-label="anchor link for suppressing-value-semantics-and-others">###</a> Suppressing Value Semantics (and others)</h3><p><strong>TODO:</strong><p>It uses <code>= delete</code> after declaring the method.<h3 id=friendship><a href=#friendship aria-label="anchor link for friendship">###</a> Friendship</h3><p>If you want to access private elements of a class (or something) in a certain function defined outside of the class, you must declare it a <code>friend</code>, otherwise they cannot access the private elements.<p>In the following example, since we want <code>ostream</code> to be the left hand side, we must declare the overloaded operator as a non-member function. Since this wants to access a private member of <code>List</code>, this must be a friend.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-meta z-c++ z-class"><span class="z-c++ z-storage z-type">class</span> </span><span class="z-meta z-c++ z-class"><span class="z-c++ z-class z-entity z-name">List</span></span><span class="z-meta z-c++ z-class"> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block">
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Allows this function's definition to access
</span>  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> its private parts.
</span>  <span class="z-c++ z-storage z-modifier">friend</span> ostream <span class="z-c++ z-keyword z-operator">&</span>
  <span class="z-meta z-c++ z-method"><span class="z-c++ z-function z-entity z-name">operator&lt;&lt;</span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group">ostream <span class="z-c z-keyword z-operator">&</span><span class="z-c++ z-variable z-parameter">output</span><span class="z-punctuation z-separator z-c++">,</span> <span class="z-c++ z-storage z-modifier">const</span> List <span class="z-c z-keyword z-operator">&</span><span class="z-c++ z-variable z-parameter">lst</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> If you didn't declare this a friend earlier,
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> then this could not access lst.head.
</span>ostream <span class="z-c++ z-keyword z-operator">&</span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">operator&lt;&lt;</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group">ostream <span class="z-c z-keyword z-operator">&</span><span class="z-c++ z-variable z-parameter">output</span><span class="z-punctuation z-separator z-c++">,</span>
                    <span class="z-c++ z-storage z-modifier">const</span> List <span class="z-c z-keyword z-operator">&</span><span class="z-c++ z-variable z-parameter">lst</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
  <span class="z-c++ z-keyword z-control">for</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span>List<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>Node <span class="z-c z-keyword z-operator">*</span>n <span class="z-c z-keyword z-operator z-assignment">=</span> lst<span class="z-punctuation z-accessor z-c++ z-dot">.</span><span class="z-c++ z-variable z-member z-other z-readwrite">head</span><span class="z-punctuation z-terminator z-c++">;</span> n<span class="z-punctuation z-terminator z-c++">;</span>
       n <span class="z-c z-keyword z-operator z-assignment">=</span> n<span class="z-punctuation z-accessor z-c++ z-arrow">-></span><span class="z-c++ z-variable z-member z-other z-readwrite">next</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
    output <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> n<span class="z-punctuation z-accessor z-c++ z-arrow">-></span><span class="z-c++ z-variable z-member z-other z-readwrite">val</span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span> <span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
  <span class="z-c++ z-keyword z-control z-flow z-return">return</span> output<span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span></code></pre><h2 id=headers-in-c><a href=#headers-in-c aria-label="anchor link for headers-in-c">##</a> Headers in C++</h2><p>In C++, it's a good idea to declare all public classes in a header file, for the same reason we do in C. This does require we use a different syntax for implementing because we have namespaces.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-meta z-c++ z-class"><span class="z-c++ z-storage z-type">class</span> </span><span class="z-meta z-c++ z-class"><span class="z-c++ z-class z-entity z-name">List</span></span><span class="z-meta z-c++ z-class"> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block">
  <span class="z-meta z-c++ z-struct"><span class="z-c++ z-storage z-type">struct</span> </span><span class="z-meta z-c++ z-struct"><span class="z-c++ z-entity z-name z-struct">Node</span></span><span class="z-meta z-c++ z-struct"> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-struct"><span class="z-meta z-c++ z-block">
    <span class="z-c z-type z-storage">int</span> val<span class="z-punctuation z-terminator z-c++">;</span>
    Node <span class="z-c++ z-keyword z-operator">*</span>next<span class="z-punctuation z-terminator z-c++">;</span>
  </span></span><span class="z-meta z-c++ z-struct"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
  Node <span class="z-c++ z-keyword z-operator">*</span>head<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c++ z-storage z-modifier">public</span><span class="z-punctuation z-section z-class z-c++">:</span>
  <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> It's not my job to declare this
</span>  <span class="z-c++ z-storage z-modifier">static</span> <span class="z-c z-type z-storage">int</span> x<span class="z-punctuation z-terminator z-c++">;</span>

  <span class="z-meta z-c++ z-method z-constructor"><span class="z-c++ z-function z-entity z-name z-constructor">List</span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-meta z-c++ z-method z-constructor"><span class="z-c++ z-function z-entity z-name z-constructor">List</span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"> <span class="z-c++ z-storage z-modifier">const</span> List <span class="z-c z-keyword z-operator">&</span> <span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-meta z-c++ z-method z-destructor"><span class="z-c++ z-function z-entity z-name z-destructor">~List</span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-c z-keyword z-operator z-variadic">...</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span></code></pre><pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> list.c
</span><span class="z-meta z-c++ z-include z-preprocessor"><span class="z-c++ z-keyword z-control z-import z-include">#include</span> <span class="z-c++ z-other z-include z-lt-gt z-quoted z-string"><span class="z-punctuation z-begin z-c++ z-definition z-string">&lt;</span>iostream<span class="z-punctuation z-end z-c++ z-definition z-string">></span></span>
</span>
<span class="z-meta z-c++ z-include z-preprocessor"><span class="z-c++ z-keyword z-control z-import z-include">#include</span> <span class="z-c++ z-include z-quoted z-string z-double"><span class="z-punctuation z-begin z-c++ z-definition z-string">"</span>list.h<span class="z-punctuation z-end z-c++ z-definition z-string">"</span></span>
</span>
<span class="z-c++ z-keyword z-control">using</span> <span class="z-c++ z-keyword z-control">namespace</span> std<span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-c++ z-storage z-modifier">static</span> <span class="z-c z-type z-storage">int</span> List<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span>x <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">5</span><span class="z-punctuation z-terminator z-c++">;</span>

<span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list">List<span class="z-punctuation z-accessor z-c++ z-double-colon">::</span><span class="z-c++ z-function z-entity z-name z-constructor">List</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
  head <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-c z-constant z-language">NULL</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Implementing copy constructor, destructor,
</span><span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> etc.
</span></span></code></pre><h2 id=throwing><a href=#throwing aria-label="anchor link for throwing">##</a> Throwing</h2><p>In C++, we can throw anything! We have the exact same <code>try-catch</code> system.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-c z-type z-storage">int</span> <span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-full-identifier z-toc-list"><span class="z-c++ z-function z-entity z-name">f</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function z-parameters"><span class="z-meta z-c++ z-group"><span class="z-c z-type z-storage">int</span> <span class="z-c++ z-variable z-parameter">val</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-function"> </span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block">
  <span class="z-c++ z-keyword z-control">if</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span>val <span class="z-c z-keyword z-operator z-comparison">&lt;=</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">0</span><span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
    <span class="z-c++ z-keyword z-control z-flow z-throw">throw</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">42</span><span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
  <span class="z-c++ z-keyword z-control">if</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span> val <span class="z-c z-keyword z-operator z-arithmetic">%</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">3</span> <span class="z-c z-keyword z-operator z-comparison">!=</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">0</span> <span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
    <span class="z-c++ z-keyword z-control z-flow z-throw">throw</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>That value isn't divisible by 3<span class="z-c z-punctuation z-definition z-string z-end">"</span></span><span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
  <span class="z-c++ z-keyword z-control z-flow z-return">return</span> val <span class="z-c z-keyword z-operator z-arithmetic">/</span> <span class="z-c++ z-constant z-decimal z-integer z-numeric">3</span><span class="z-punctuation z-terminator z-c++">;</span>
</span></span><span class="z-meta z-c++ z-function"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>

<span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Calling code
</span><span class="z-c++ z-keyword z-control">try</span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
  <span class="z-c z-type z-storage">int</span> result <span class="z-c z-keyword z-operator z-assignment">=</span> <span class="z-meta z-c++ z-function-call"><span class="z-c++ z-function z-variable">f</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function-call"><span class="z-meta z-c++ z-group"> val </span></span><span class="z-meta z-c++ z-function-call"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
  cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> result <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> endl<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-punctuation z-section z-end z-block z-c++">}</span></span> <span class="z-c++ z-keyword z-control">catch</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span> <span class="z-c++ z-storage z-modifier">const</span> <span class="z-c z-type z-storage">char</span> <span class="z-c z-keyword z-operator">*</span>str <span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
  cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Error: <span class="z-c z-punctuation z-definition z-string z-end">"</span></span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> str <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> endl<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-punctuation z-section z-end z-block z-c++">}</span></span> <span class="z-c++ z-keyword z-control">catch</span> <span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span> <span class="z-c z-type z-storage">int</span> code <span class="z-punctuation z-section z-group z-end z-c++">)</span></span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span>
  cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span>Internal Error: <span class="z-c z-punctuation z-definition z-string z-end">"</span></span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> code <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> endl<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-punctuation z-section z-end z-block z-c++">}</span></span>
</span></code></pre><h2 id=inheritance-1><a href=#inheritance-1 aria-label="anchor link for inheritance-1">##</a> Inheritance</h2><p>We'll only cover <em>public</em> inheritance. You can look up private (and protected) inheritance.<p>As you know, the main reason to do inheritance is for abstraction (not code reuse!).<h3 id=virtual-methods><a href=#virtual-methods aria-label="anchor link for virtual-methods">###</a> Virtual Methods</h3><p>Virtual functions are the way you tell the compiler you'd like to use <em>single dispatch</em> for that function.<h3 id=const-methods><a href=#const-methods aria-label="anchor link for const-methods">###</a> Const Methods</h3><p>Const methods are member functions that are not allowed to mutate the object. You can only call const methods on const objects. You can call both const methods and non-const methods on non-const objects.<pre class="z-code language-cpp" data-lang=cpp><code class=language-cpp data-lang=cpp><span class="z-c++ z-source"><span class="z-meta z-c++ z-class"><span class="z-c++ z-storage z-type">class</span> </span><span class="z-meta z-c++ z-class"><span class="z-c++ z-class z-entity z-name">EmailContact</span></span><span class="z-meta z-c++ z-class"> <span class="z-punctuation z-separator z-c++">:</span> <span class="z-c++ z-storage z-modifier">public</span> <span class="z-c++ z-entity z-inherited-class z-other">Contact</span> <span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block">
  <span class="z-c z-type z-storage">char</span> <span class="z-c++ z-keyword z-operator">*</span>email<span class="z-punctuation z-terminator z-c++">;</span>
<span class="z-c++ z-storage z-modifier">public</span><span class="z-punctuation z-section z-class z-c++">:</span>
  <span class="z-c z-keyword z-operator z-variadic">...</span><span class="z-punctuation z-terminator z-c++">;</span>
  <span class="z-c z-type z-storage">void</span> <span class="z-meta z-c++ z-method"><span class="z-c++ z-function z-entity z-name">print</span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-parameters z-method"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span><span class="z-meta z-c++ z-method"> <span class="z-c++ z-storage z-modifier">const</span> <span class="z-c++ z-storage z-modifier">override</span> </span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-begin z-block z-c++">{</span></span></span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block">
    <span class="z-c z-comment z-double-slash z-line"><span class="z-c z-punctuation z-definition z-comment">//</span> Print our name and our email.
</span>    cout <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-meta z-c++ z-function-call"><span class="z-c++ z-function z-variable">getName</span><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-begin z-c++">(</span></span></span><span class="z-meta z-c++ z-function-call"></span><span class="z-meta z-c++ z-function-call"><span class="z-meta z-c++ z-group"><span class="z-punctuation z-section z-group z-end z-c++">)</span></span></span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> <span class="z-c z-string z-quoted z-double"><span class="z-c z-punctuation z-definition z-string z-begin">"</span> <span class="z-c z-punctuation z-definition z-string z-end">"</span></span> <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> email <span class="z-c z-keyword z-operator z-arithmetic">&lt;&lt;</span> endl<span class="z-punctuation z-terminator z-c++">;</span>
  </span></span><span class="z-meta z-c++ z-method"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span>
</span></span><span class="z-meta z-c++ z-class"><span class="z-meta z-c++ z-block"><span class="z-punctuation z-section z-end z-block z-c++">}</span></span></span><span class="z-punctuation z-terminator z-c++">;</span>
</span></code></pre></article>