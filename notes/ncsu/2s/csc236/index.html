<!DOCTYPE html><html lang=en><meta charset=utf-8><meta content="width=device-width,initial-scale=1" name=viewport><title>Eli | CSC 236: Computer Architecture & Assembly</title><link href=/styles.css rel=stylesheet><link href=/favicon-32.png rel=icon sizes=32x32><link href=/favicon-128.png rel=icon sizes=128x128><link href=/favicon-180.png rel=icon sizes=180x180><link href=/favicon-192.png rel=icon sizes=192x192><style id=MJX-CHTML-styles>mjx-container[jax=CHTML]{line-height:0}mjx-container [space="1"]{margin-left:.111em}mjx-container [space="2"]{margin-left:.167em}mjx-container [space="3"]{margin-left:.222em}mjx-container [space="4"]{margin-left:.278em}mjx-container [space="5"]{margin-left:.333em}mjx-container [rspace="1"]{margin-right:.111em}mjx-container [rspace="2"]{margin-right:.167em}mjx-container [rspace="3"]{margin-right:.222em}mjx-container [rspace="4"]{margin-right:.278em}mjx-container [rspace="5"]{margin-right:.333em}mjx-container [size="s"]{font-size:70.7%}mjx-container [size=ss]{font-size:50%}mjx-container [size=Tn]{font-size:60%}mjx-container [size=sm]{font-size:85%}mjx-container [size=lg]{font-size:120%}mjx-container [size=Lg]{font-size:144%}mjx-container [size=LG]{font-size:173%}mjx-container [size=hg]{font-size:207%}mjx-container [size=HG]{font-size:249%}mjx-container [width=full]{width:100%}mjx-box{display:inline-block}mjx-block{display:block}mjx-itable{display:inline-table}mjx-row{display:table-row}mjx-row>*{display:table-cell}mjx-mtext{display:inline-block;text-align:left}mjx-mstyle{display:inline-block}mjx-merror{display:inline-block;color:red;background-color:#ff0}mjx-mphantom{visibility:hidden}_::-webkit-full-page-media,_:future,:root mjx-container{will-change:opacity}mjx-assistive-mml{position:absolute!important;top:0;left:0;clip:rect(1px,1px,1px,1px);padding:1px 0 0 0!important;border:0!important;display:block!important;width:auto!important;overflow:hidden!important;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}mjx-assistive-mml[display=block]{width:100%!important}mjx-math{display:inline-block;text-align:left;line-height:0;text-indent:0;font-style:normal;font-weight:400;font-size:100%;font-size-adjust:none;letter-spacing:normal;border-collapse:collapse;word-wrap:normal;word-spacing:normal;white-space:nowrap;direction:ltr;padding:1px 0}mjx-container[jax=CHTML][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=CHTML][display=true][width=full]{display:flex}mjx-container[jax=CHTML][display=true] mjx-math{padding:0}mjx-container[jax=CHTML][justify=left]{text-align:left}mjx-container[jax=CHTML][justify=right]{text-align:right}mjx-mi{display:inline-block;text-align:left}mjx-c{display:inline-block}mjx-utext{display:inline-block;padding:.75em 0 .2em 0}mjx-mo{display:inline-block;text-align:left}mjx-stretchy-h{display:inline-table;width:100%}mjx-stretchy-h>*{display:table-cell;width:0}mjx-stretchy-h>*>mjx-c{display:inline-block;transform:scalex(1.0000001)}mjx-stretchy-h>*>mjx-c::before{display:inline-block;width:initial}mjx-stretchy-h>mjx-ext{overflow:hidden;overflow:clip visible;width:100%}mjx-stretchy-h>mjx-ext>mjx-c::before{transform:scalex(500)}mjx-stretchy-h>mjx-ext>mjx-c{width:0}mjx-stretchy-h>mjx-beg>mjx-c{margin-right:-.1em}mjx-stretchy-h>mjx-end>mjx-c{margin-left:-.1em}mjx-stretchy-v{display:inline-block}mjx-stretchy-v>*{display:block}mjx-stretchy-v>mjx-beg{height:0}mjx-stretchy-v>mjx-end>mjx-c{display:block}mjx-stretchy-v>*>mjx-c{transform:scaley(1.0000001);transform-origin:left center;overflow:hidden}mjx-stretchy-v>mjx-ext{display:block;height:100%;box-sizing:border-box;border:0 solid transparent;overflow:hidden;overflow:visible clip}mjx-stretchy-v>mjx-ext>mjx-c::before{width:initial;box-sizing:border-box}mjx-stretchy-v>mjx-ext>mjx-c{transform:scaleY(500) translateY(.075em);overflow:visible}mjx-mark{display:inline-block;height:0}mjx-munder{display:inline-block;text-align:left}mjx-over{text-align:left}mjx-munder:not([limits=false]){display:inline-table}mjx-munder>mjx-row{text-align:left}mjx-under{padding-bottom:.1em}mjx-TeXAtom{display:inline-block;text-align:left}mjx-msub{display:inline-block;text-align:left}mjx-msup{display:inline-block;text-align:left}mjx-mn{display:inline-block;text-align:left}mjx-mfrac{display:inline-block;text-align:left}mjx-frac{display:inline-block;vertical-align:.17em;padding:0 .22em}mjx-frac[type="d"]{vertical-align:.04em}mjx-frac[delims]{padding:0 .1em}mjx-frac[atop]{padding:0 .12em}mjx-frac[atop][delims]{padding:0}mjx-dtable{display:inline-table;width:100%}mjx-dtable>*{font-size:2000%}mjx-dbox{display:block;font-size:5%}mjx-num{display:block;text-align:center}mjx-den{display:block;text-align:center}mjx-mfrac[bevelled]>mjx-num{display:inline-block}mjx-mfrac[bevelled]>mjx-den{display:inline-block}mjx-den[align=right],mjx-num[align=right]{text-align:right}mjx-den[align=left],mjx-num[align=left]{text-align:left}mjx-nstrut{display:inline-block;height:.054em;width:0;vertical-align:-.054em}mjx-nstrut[type="d"]{height:.217em;vertical-align:-.217em}mjx-dstrut{display:inline-block;height:.505em;width:0}mjx-dstrut[type="d"]{height:.726em}mjx-line{display:block;box-sizing:border-box;min-height:1px;height:.06em;border-top:.06em solid;margin:.06em -.1em;overflow:hidden}mjx-line[type="d"]{margin:.18em -.1em}mjx-mrow{display:inline-block;text-align:left}mjx-c::before{display:block;width:0}.MJX-TEX{font-family:MJXZERO,MJXTEX}.TEX-B{font-family:MJXZERO,MJXTEX-B}.TEX-I{font-family:MJXZERO,MJXTEX-I}.TEX-MI{font-family:MJXZERO,MJXTEX-MI}.TEX-BI{font-family:MJXZERO,MJXTEX-BI}.TEX-S1{font-family:MJXZERO,MJXTEX-S1}.TEX-S2{font-family:MJXZERO,MJXTEX-S2}.TEX-S3{font-family:MJXZERO,MJXTEX-S3}.TEX-S4{font-family:MJXZERO,MJXTEX-S4}.TEX-A{font-family:MJXZERO,MJXTEX-A}.TEX-C{font-family:MJXZERO,MJXTEX-C}.TEX-CB{font-family:MJXZERO,MJXTEX-CB}.TEX-FR{font-family:MJXZERO,MJXTEX-FR}.TEX-FRB{font-family:MJXZERO,MJXTEX-FRB}.TEX-SS{font-family:MJXZERO,MJXTEX-SS}.TEX-SSB{font-family:MJXZERO,MJXTEX-SSB}.TEX-SSI{font-family:MJXZERO,MJXTEX-SSI}.TEX-SC{font-family:MJXZERO,MJXTEX-SC}.TEX-T{font-family:MJXZERO,MJXTEX-T}.TEX-V{font-family:MJXZERO,MJXTEX-V}.TEX-VB{font-family:MJXZERO,MJXTEX-VB}mjx-stretchy-h mjx-c,mjx-stretchy-v mjx-c{font-family:MJXZERO,MJXTEX-S1,MJXTEX-S4,MJXTEX,MJXTEX-A!important}@font-face{font-family:MJXZERO;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Zero.woff) format("woff")}@font-face{font-family:MJXTEX;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-B;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff) format("woff")}@font-face{font-family:MJXTEX-I;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff) format("woff")}@font-face{font-family:MJXTEX-MI;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff) format("woff")}@font-face{font-family:MJXTEX-BI;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff) format("woff")}@font-face{font-family:MJXTEX-S1;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-S2;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-S3;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-S4;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-A;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-C;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-CB;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff) format("woff")}@font-face{font-family:MJXTEX-FR;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-FRB;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff) format("woff")}@font-face{font-family:MJXTEX-SS;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-SSB;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff) format("woff")}@font-face{font-family:MJXTEX-SSI;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff) format("woff")}@font-face{font-family:MJXTEX-SC;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-T;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-V;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff) format("woff")}@font-face{font-family:MJXTEX-VB;src:url(https://cdn.jsdelivr.net/npm/mathjax@3/es5/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff) format("woff")}mjx-c.mjx-c1D463.TEX-I::before{padding:.443em .485em .011em 0;content:"v"}mjx-c.mjx-c1D437.TEX-I::before{padding:.683em .828em 0 0;content:"D"}mjx-c.mjx-c1D45F.TEX-I::before{padding:.442em .451em .011em 0;content:"r"}mjx-c.mjx-c3D::before{padding:.583em .778em .082em 0;content:"="}mjx-c.mjx-c2211.TEX-S2::before{padding:.95em 1.444em .45em 0;content:"\2211"}mjx-c.mjx-c1D451.TEX-I::before{padding:.694em .52em .01em 0;content:"d"}mjx-c.mjx-c1D456.TEX-I::before{padding:.661em .345em .011em 0;content:"i"}mjx-c.mjx-c2208::before{padding:.54em .667em .04em 0;content:"\2208"}mjx-c.mjx-c2217::before{padding:.465em .5em 0 0;content:"\2217"}mjx-c.mjx-c2E::before{padding:.12em .278em 0 0;content:"."}mjx-c.mjx-c31::before{padding:.666em .5em 0 0;content:"1"}mjx-c.mjx-c30::before{padding:.666em .5em .022em 0;content:"0"}mjx-c.mjx-c32::before{padding:.666em .5em 0 0;content:"2"}mjx-c.mjx-c1D44F.TEX-I::before{padding:.694em .429em .011em 0;content:"b"}mjx-c.mjx-c2B::before{padding:.583em .778em .082em 0;content:"+"}mjx-c.mjx-c2212::before{padding:.583em .778em .082em 0;content:"\2212"}mjx-c.mjx-c1D447.TEX-I::before{padding:.677em .704em 0 0;content:"T"}mjx-c.mjx-c1D436.TEX-I::before{padding:.705em .76em .022em 0;content:"C"}mjx-c.mjx-c1D441.TEX-I::before{padding:.683em .888em 0 0;content:"N"}mjx-c.mjx-c28::before{padding:.75em .389em .25em 0;content:"("}mjx-c.mjx-c29::before{padding:.75em .389em .25em 0;content:")"}mjx-c.mjx-c1D465.TEX-I::before{padding:.442em .572em .011em 0;content:"x"}mjx-c.mjx-c1D466.TEX-I::before{padding:.442em .49em .205em 0;content:"y"}mjx-c.mjx-c2F::before{padding:.75em .5em .25em 0;content:"/"}mjx-c.mjx-c35::before{padding:.666em .5em .022em 0;content:"5"}mjx-c.mjx-c36::before{padding:.666em .5em .022em 0;content:"6"}mjx-c.mjx-c34::before{padding:.677em .5em 0 0;content:"4"}mjx-c.mjx-c33::before{padding:.665em .5em .022em 0;content:"3"}mjx-c.mjx-c2248::before{padding:.483em .778em 0 0;content:"\2248"}mjx-c.mjx-c38::before{padding:.666em .5em .022em 0;content:"8"}mjx-c.mjx-cB1::before{padding:.666em .778em 0 0;content:"\B1"}mjx-c.mjx-c1D45B.TEX-I::before{padding:.442em .6em .011em 0;content:"n"}mjx-c.mjx-cD7::before{padding:.491em .778em 0 0;content:"\D7"}mjx-c.mjx-c1D452.TEX-I::before{padding:.442em .466em .011em 0;content:"e"}mjx-c.mjx-c2264::before{padding:.636em .778em .138em 0;content:"\2264"}mjx-c.mjx-c3C::before{padding:.54em .778em .04em 0;content:"<"}mjx-c.mjx-c1D70B.TEX-I::before{padding:.431em .57em .011em 0;content:"\3C0"}mjx-c.mjx-c221E::before{padding:.442em 1em .011em 0;content:"\221E"}mjx-c.mjx-c74::before{padding:.615em .389em .01em 0;content:"t"}mjx-c.mjx-c69::before{padding:.669em .278em 0 0;content:"i"}mjx-c.mjx-c6D::before{padding:.442em .833em 0 0;content:"m"}mjx-c.mjx-c65::before{padding:.448em .444em .011em 0;content:"e"}mjx-c.mjx-c2211.TEX-S1::before{padding:.75em 1.056em .25em 0;content:"\2211"}mjx-c.mjx-c6E::before{padding:.442em .556em 0 0;content:"n"}mjx-c.mjx-c73::before{padding:.448em .394em .011em 0;content:"s"}mjx-c.mjx-c72::before{padding:.442em .392em 0 0;content:"r"}mjx-c.mjx-c75::before{padding:.442em .556em .011em 0;content:"u"}mjx-c.mjx-c63::before{padding:.448em .444em .011em 0;content:"c"}mjx-c.mjx-c6F::before{padding:.448em .5em .01em 0;content:"o"}mjx-c.mjx-c61::before{padding:.448em .5em .011em 0;content:"a"}mjx-c.mjx-c6B::before{padding:.694em .528em 0 0;content:"k"}mjx-c.mjx-c79::before{padding:.431em .528em .204em 0;content:"y"}mjx-c.mjx-c6C::before{padding:.694em .278em 0 0;content:"l"}mjx-c.mjx-c64::before{padding:.694em .556em .011em 0;content:"d"}</style><nav><h2><a href=/ >e l i</a></h2><ul><li><a href=/blog/ >blog</a><li><a href=/projects/ >projects</a><li><a href=/notes/ >notes</a></ul></nav><article><header><h1 class=title>CSC 236: Computer Architecture & Assembly</h1><p>Instructor: Dr. Vincent Freeh | Semester: Spring 2020<p><h3>Table of Contents</h3><ul><li><a href=#views-of-system>Views of System</a><li><a href=#number-systems>Number Systems</a><li><a href=#multiplication-and-division>Multiplication and Division</a><li><a href=#computer-architecture>Computer Architecture</a><li><a href=#history>History</a><li><a href=#architecture-woes>Architecture Woes</a><li><a href=#x86-anatomy>x86 Anatomy</a><li><a href=#dos-anatomy>DOS Anatomy</a><li><a href=#assembly>Assembly</a><li><a href=#anatomy-of-machine-code>Anatomy of Machine Code</a><li><a href=#boolean-algebra-and-computer-hardware>Boolean Algebra and Computer Hardware</a><li><a href=#arm-assembly>ARM Assembly</a><li><a href=#java-virtual-machine-jvm>Java Virtual Machine (JVM)</a><li><a href=#microcode>Microcode</a><li><a href=#interrupts-and-i-o>Interrupts and I/O</a><li><a href=#floating-point-numbers>Floating Point Numbers</a><li><a href=#computer-architecture-design>Computer Architecture Design</a><li><a href=#newer-x86>Newer x86</a><li><a href=#hardware-description-languages>Hardware Description Languages</a></ul></header><h1 id=views-of-system><a href=#views-of-system aria-label="anchor link for views-of-system">#</a> Views of System</h1><p>There are two orthogonal views of a system, logical and physical. Logical is reasoning about function. Physical is reasoning about construction. This class attempts to analyze a computer using both. Logical view is also the architectural view.<h1 id=number-systems><a href=#number-systems aria-label="anchor link for number-systems">#</a> Number Systems</h1><p>Computers, like us, use a positional number system. You already know this, so I won't go too deep into it, but basically to find the value <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D463"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>v</mi></math></mjx-assistive-mml></mjx-container> of some string of digits <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D437"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>D</mi></math></mjx-assistive-mml></mjx-container> in some radix <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45F"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>r</mi></math></mjx-assistive-mml></mjx-container> (or base), you do<p><mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative display=true><mjx-math aria-hidden=true class=MJX-TEX display=true style=margin-left:0;margin-right:0><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D463"></mjx-c></mjx-mi><mjx-mo class=mjx-n space=4><mjx-c class=mjx-c3D></mjx-c></mjx-mo><mjx-munder space=4><mjx-row><mjx-base style=padding-left:.106em><mjx-mo class=mjx-lop><mjx-c class="mjx-c2211 TEX-S2"></mjx-c></mjx-mo></mjx-base></mjx-row><mjx-row><mjx-under style=padding-top:.167em><mjx-texatom texclass=ORD size=s><mjx-msub><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D451"></mjx-c></mjx-mi><mjx-script style=vertical-align:-.15em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D456"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class=mjx-n><mjx-c class=mjx-c2208></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D437"></mjx-c></mjx-mi></mjx-texatom></mjx-under></mjx-row></mjx-munder><mjx-msub space=2><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D451"></mjx-c></mjx-mi><mjx-script style=vertical-align:-.15em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D456"></mjx-c></mjx-mi></mjx-script></mjx-msub><mjx-mo class=mjx-n space=3><mjx-c class=mjx-c2217></mjx-c></mjx-mo><mjx-msup space=3><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45F"></mjx-c></mjx-mi><mjx-script style=vertical-align:.413em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D456"></mjx-c></mjx-mi></mjx-script></mjx-msup><mjx-mo class=mjx-n><mjx-c class=mjx-c2E></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=block unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML display=block><mi>v</mi><mo>=</mo><munder><mo data-mjx-texclass=OP>∑</mo><mrow data-mjx-texclass=ORD><msub><mi>d</mi><mi>i</mi></msub><mo>∈</mo><mi>D</mi></mrow></munder><msub><mi>d</mi><mi>i</mi></msub><mo>∗</mo><msup><mi>r</mi><mi>i</mi></msup><mo>.</mo></math></mjx-assistive-mml></mjx-container><p>In this class, we will follow the math standard of postfixing a number with a subscript of the radix (or base) rather than the standard computer science prefix. For example, we write <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msub><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c><mjx-c class=mjx-c30></mjx-c><mjx-c class=mjx-c31></mjx-c></mjx-mn><mjx-script style=vertical-align:-.15em><mjx-mn class=mjx-n size=s><mjx-c class=mjx-c32></mjx-c></mjx-mn></mjx-script></mjx-msub></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msub><mn>101</mn><mn>2</mn></msub></math></mjx-assistive-mml></mjx-container> rather than <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c30></mjx-c></mjx-mn><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D44F"></mjx-c></mjx-mi><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c><mjx-c class=mjx-c30></mjx-c><mjx-c class=mjx-c31></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>0</mn><mi>b</mi><mn>101</mn></math></mjx-assistive-mml></mjx-container>.<h2 id=unsigned-integers><a href=#unsigned-integers aria-label="anchor link for unsigned-integers">##</a> Unsigned Integers</h2><p>Unsigned binary integers are pretty simple. All bits (or binary digits) are value digits.<p>We represent these without a <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c2B></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>+</mo></math></mjx-assistive-mml></mjx-container> or <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c2212></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>−</mo></math></mjx-assistive-mml></mjx-container>.<h3 id=overflows><a href=#overflows aria-label="anchor link for overflows">###</a> Overflows</h3><p>What happens if we run out of bits after some operation? Well, we get an overflow! This means we lose the largest bit. Think about an odometer (or some other counter) rolling over.<p><em>Note:</em> Most hardware detects overflows like this, but software doesn't always pay attention because not all platforms support it.<h2 id=signed-integers><a href=#signed-integers aria-label="anchor link for signed-integers">##</a> Signed Integers</h2><p>There are many representations for signed integers. The most common is two's complement, but there used to be a lot of diversity.<p>We represent these with a mandatory <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c2B></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>+</mo></math></mjx-assistive-mml></mjx-container> or <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c2212></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>−</mo></math></mjx-assistive-mml></mjx-container>.<h3 id=signed-magnitude><a href=#signed-magnitude aria-label="anchor link for signed-magnitude">###</a> Signed Magnitude</h3><p><em>This was used by the Gemini program in NASA.</em><p>The MSB is the sign bit (<code>0</code> is positive, <code>1</code> is negative), the rest is the magnitude. You choose the most significant bit normally because that gives the signed positive and unsigned numbers the same representation for most numbers.<pre class=z-code><code><span class="z-plain z-text">0000 0111 == +7
1000 0111 == -7
</span></code></pre><p>The rules for addition are:<ul><li>If the signs are the same, add the digits as if they were unsigned. The result has the sign of the operands.<li>If the magnitudes are different, subtract the digits of the smaller number from the digits of the larger number. The result has the sign of the larger number.<li>If the magnitudes are the same, the result is zero, either positive or negative.</ul><p><em>Why isn't this used?</em><ul><li>There is <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c2B></mjx-c></mjx-mo><mjx-mn class=mjx-n><mjx-c class=mjx-c30></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>+</mo><mn>0</mn></math></mjx-assistive-mml></mjx-container> (<code>0000 0000</code>) and <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c2212></mjx-c></mjx-mo><mjx-mn class=mjx-n><mjx-c class=mjx-c30></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>−</mo><mn>0</mn></math></mjx-assistive-mml></mjx-container> (<code>1000 0000</code>).<li>Arithmetic is complicated.</ul><h3 id=one-s-complement><a href=#one-s-complement aria-label="anchor link for one-s-complement">###</a> One's Complement</h3><p><em>This was used by the Apollo program, the PDP-1, and Univac 1100.</em><p>The MSB is the sign bit (<code>0</code> is positive, <code>1</code> is negative). If the sign is negative, you invert the bits to get the positive version. <em>This is really easy to do in hardware.</em><pre class=z-code><code><span class="z-plain z-text">0000 0111 == +7
1111 1000 == -7
</span></code></pre><p>The rules for addition are, to add the binary as if it was unsigned. Then you do an <em>end around carry</em>, where if you have a carry bit, you add one again.<pre class=z-code><code><span class="z-plain z-text"> 111
  1110 # -1
+ 1110 # -1
  ----
  1100
     1
  ----
  1101 # -2
</span></code></pre><p><em>Why is this good?</em> Negation and addition is really quick and easy. The end around carry is simple in hardware.<p><em>Why isn't this used?</em> It has a positive and negative zero, which have weird rules. End around carries aren't hard, but still something you have to consider.<h3 id=two-s-complement><a href=#two-s-complement aria-label="anchor link for two-s-complement">###</a> Two's Complement</h3><p><em>This is used by almost all computers now.</em><p>The two's complement <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D447"></mjx-c></mjx-mi><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D436"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>T</mi><mi>C</mi></math></mjx-assistive-mml></mjx-container> for a number with <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D451"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>d</mi></math></mjx-assistive-mml></mjx-container> bits is <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D441"></mjx-c></mjx-mi><mjx-mo class=mjx-n space=3><mjx-c class=mjx-c2B></mjx-c></mjx-mo><mjx-mi class=mjx-i space=3><mjx-c class="TEX-I mjx-c1D447"></mjx-c></mjx-mi><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D436"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c28></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D441"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c29></mjx-c></mjx-mo><mjx-mo class=mjx-n space=4><mjx-c class=mjx-c3D></mjx-c></mjx-mo><mjx-msup space=4><mjx-mn class=mjx-n><mjx-c class=mjx-c32></mjx-c></mjx-mn><mjx-script style=vertical-align:.363em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D451"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>N</mi><mo>+</mo><mi>T</mi><mi>C</mi><mo stretchy=false>(</mo><mi>N</mi><mo stretchy=false>)</mo><mo>=</mo><msup><mn>2</mn><mi>d</mi></msup></math></mjx-assistive-mml></mjx-container>. We negate a number by taking the two's complement of it. In other words, we solve for <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D447"></mjx-c></mjx-mi><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D436"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c28></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D441"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c29></mjx-c></mjx-mo></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>T</mi><mi>C</mi><mo stretchy=false>(</mo><mi>N</mi><mo stretchy=false>)</mo></math></mjx-assistive-mml></mjx-container> to get <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D447"></mjx-c></mjx-mi><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D436"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c28></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D441"></mjx-c></mjx-mi><mjx-mo class=mjx-n><mjx-c class=mjx-c29></mjx-c></mjx-mo><mjx-mo class=mjx-n space=4><mjx-c class=mjx-c3D></mjx-c></mjx-mo><mjx-msup space=4><mjx-mn class=mjx-n><mjx-c class=mjx-c32></mjx-c></mjx-mn><mjx-script style=vertical-align:.363em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D451"></mjx-c></mjx-mi></mjx-script></mjx-msup><mjx-mo class=mjx-n space=3><mjx-c class=mjx-c2212></mjx-c></mjx-mo><mjx-mi class=mjx-i space=3><mjx-c class="TEX-I mjx-c1D441"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>T</mi><mi>C</mi><mo stretchy=false>(</mo><mi>N</mi><mo stretchy=false>)</mo><mo>=</mo><msup><mn>2</mn><mi>d</mi></msup><mo>−</mo><mi>N</mi></math></mjx-assistive-mml></mjx-container>. Solve for that in your done! Luckily, in hardware there is a very easy way to do this. You just flip the bits and add one. When looking at the binary as a person, you keep everything to the right of the first 1, including the 1, and flip everything to the left.<pre class=z-code><code><span class="z-plain z-text">0000 0111 == +7
1111 1001 == -7
</span></code></pre><p>The rules for addition are, just add the binary as if it was unsigned. That's it!<figure><img src=twos_complement.png><figcaption><p>Two's Complement Wheel</figcaption></figure><p><em>Why is this used?</em> It has the all the benefits of one's complement, but it only has a single 0. Nice!<p><em>How do you detect overflow?</em> When summing numbers with like signs, the result should have the same sign. When summing numbers of different signs, they cannot overflow, since the magnitude is decreasing. In hardware, you just make sure the sign bit is the same as the carry-out bit.<h1 id=multiplication-and-division><a href=#multiplication-and-division aria-label="anchor link for multiplication-and-division">#</a> Multiplication and Division</h1><p>Sadly, no one has found out a way to do signed and unsigned multiplication (and division) with the same instruction.<h2 id=multiplication><a href=#multiplication aria-label="anchor link for multiplication">##</a> Multiplication</h2><p>Multiplication can get really big. <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>x</mi></math></mjx-assistive-mml></mjx-container> digits times <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D466"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>y</mi></math></mjx-assistive-mml></mjx-container> digits requires <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D465"></mjx-c></mjx-mi><mjx-mo class=mjx-n space=3><mjx-c class=mjx-c2B></mjx-c></mjx-mo><mjx-mi class=mjx-i space=3><mjx-c class="TEX-I mjx-c1D466"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>x</mi><mo>+</mo><mi>y</mi></math></mjx-assistive-mml></mjx-container> digits. So, how do you multiply two words? It could give you a 32 bit back, in x86 we handle this by storing the result in a different place and potentially in two registers.<ul><li><code>[i]mul byte</code>: <code>al * byte = ax</code><li><code>[i]mul word</code>: <code>ax * word = dx:ax</code></ul><p><em>Note:</em> <code>mul</code> is unsigned multiplication. <code>imul</code> is signed multiplication.<p>For performance reasons, we often to know whether we ended up needing more space than you were originally used (basically another digit). We store this information in the carry flag (<code>CF</code>), to tell you if the significant part of the solution outgrew your original data size. (<code>CF=1</code> means it did outgrow. <code>CF=0</code> means it did not.) This works because multiplication can never overflow.<p>Weirdly, you can't multiply by an immediate, only a register or memory value.<h2 id=division><a href=#division aria-label="anchor link for division">##</a> Division</h2><p>We often care about both the remainder and the quotient, so we store both the remainder and quotient.<ul><li><code>[i]div byte</code>: <code>ax</code> is the numerator, <code>byte</code> is the divisor. <code>ah</code> is the remainder, <code>al</code> the quotient.<li><code>[i]div word</code>: <code>dx:ax</code> is the numerator, <code>word</code> is the divisor. <code>dx</code> is the remainder, <code>ax</code> the quotient.</ul><p><em>Note:</em> <code>div</code> is unsigned multiplication. <code>idiv</code> is signed multiplication.<p><em>Note:</em> Status flags are not updated by divide.<p>If you want to convert a word into long / double word, you use the <code>cwd</code> instruction. This acts on <code>ax</code>.<p>You can get a divide overflow by not having enough space for the quotient. (You'll always have room for the remainder.) If you get a divide overflow (e.g. by dividing by zero or by dividing something large by something small), DOS interrupts your program and then terminates it. The way to get around this is normally either to check your division before you do it or to write an interrupt handler. <em>You probably shouldn't do this</em>.<p>We won't prove it here, but if the upper half of the digits of the denominator is less than that of the numerator, then the division will overflow. Otherwise, it won't. In other words, we want a large denominator to not overflow.<p>The sign of the quotient acts exactly like you think it would. For the remainder, you have to deal with negative remainders. Remember that the remainder is defined as <code>quotient * divisor + remainder = value</code>. For example, the remainder of <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c2212></mjx-c></mjx-mo><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn><mjx-texatom texclass=ORD><mjx-mo class=mjx-n><mjx-c class=mjx-c2F></mjx-c></mjx-mo></mjx-texatom><mjx-mn class=mjx-n><mjx-c class=mjx-c35></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>−</mo><mn>1</mn><mrow data-mjx-texclass=ORD><mo>/</mo></mrow><mn>5</mn></math></mjx-assistive-mml></mjx-container> is <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-c2212></mjx-c></mjx-mo><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>−</mo><mn>1</mn></math></mjx-assistive-mml></mjx-container> because the quotient would be 0.<h1 id=computer-architecture><a href=#computer-architecture aria-label="anchor link for computer-architecture">#</a> Computer Architecture</h1><p>Modern computers follow the John von Neumann architecture, where there is <em>memory</em>, which holds <em>instructions</em> and <em>data</em>, and a <em>processor</em>, which executes instructions on data.<p><em>Note:</em> Most of what a CPU has is actually a cache.<h2 id=anatomy-of-instructions><a href=#anatomy-of-instructions aria-label="anchor link for anatomy-of-instructions">##</a> Anatomy of Instructions</h2><p>Instructions (and thus assembly) is made up of <strong>opcodes</strong> and <strong>operands</strong>. Opcodes define what operation you want to perform and operands define what data you are operating on.<p>Instructions are normally executed in a <strong>pipeline</strong>, where each step of the pipeline performs some different operation. Multiple instructions can be in the pipeline at once, allowing the CPU to execute "multiple things at once". However, sometimes the pipeline has "bubbles", where nothing is occupying that spot in the pipeline. This is due to conditional branching primarily. The hardware can get around this with speculative execution, where it takes a guess and either trashes the pipeline if it guessed wrong or executes as normal if it was right. (This isn't important for this class.) A standard, simple pipeline is fetch, decode, execute, and store.<p><em>Note:</em> Modern Intel CPUs have complex instruction sets, but they have a "translator" that converts the instructions into CISC <em>operations</em>, which are actually executed.<p>There are two main "philosophies" on what instructions the hardware should provide and why.<h3 id=complex-instruction-set-computer-cisc><a href=#complex-instruction-set-computer-cisc aria-label="anchor link for complex-instruction-set-computer-cisc">###</a> Complex Instruction Set Computer (CISC)</h3><p>The hardware provides <em>many</em> functions natively, having many special instructions and many address modes. What was used primarily from the 1960s to 1990s. x86 is CISC.<p><em>Why is this no longer preferred?</em> Instructions have <strong>variable size</strong> and <strong>variable execution time</strong>. This tends to make it <strong>slower</strong> and <strong>harder to decode</strong>.<h3 id=reduced-instruction-set-computer-risc><a href=#reduced-instruction-set-computer-risc aria-label="anchor link for reduced-instruction-set-computer-risc">###</a> Reduced Instruction Set Computer (RISC)</h3><p>The hardware provides <em>few</em> instructions natively, only having simple load and store from memory and the rest operating on registers.<p><em>Why is this now preferred?</em> Instructions have <strong>fixed size</strong> and have <strong>fixed execution time</strong>. This makes it <strong>faster</strong> and <strong>easier to decode</strong>.<h2 id=memory-technology><a href=#memory-technology aria-label="anchor link for memory-technology">##</a> Memory Technology</h2><p>There are a bunch of different kinds of memory which are used at different times because of their different strengths and weaknesses.<ul><li>SRAM (Static Ram): Fast, expensive, uses transistors. Used as part of CPU cache.<ul><li>6 transistors per bit.<li>Access Time: 5-10 ns.<li>~$1000/GiB.</ul><li>DRAM (Dynamic Ram): Slow, less expensive, capacitors. Used as part of main memory. Bunch of types.<ul><li>1 transistors and 1 capacitor per bit.<li>Access time: 50-150 ns.<li>~$10/GiB.<li>Types:<ul><li>EDO: Faster DRAM.<li>SDRAM: Synchronous DRAM.<li>DDR-SDRAM: Double Data Rate SDRAM.<li>RDRAM: Rambus DRAM.</ul></ul></ul><p><em>There's also SCM (storage class memory), which is basically an SSD that is as fast as RAM.</em><h2 id=anatomy-of-cpu><a href=#anatomy-of-cpu aria-label="anchor link for anatomy-of-cpu">##</a> Anatomy of CPU</h2><ul><li>Registers: Data held within the CPU. Can be <em>general purpose</em> or contain <em>CPU state</em>.<ul><li>Special Registers (x86):<ul><li>Program Counter / Instruction Address Register (IAR): Address of next instruction. By default, it increments after every instruction.</ul></ul><li>Arithmetic Logic Unit (ALU): A chip containing circuits which do various operations, which the CPU can select.<ul><li>Common Chips:<ul><li>Add<li>Invert<li>Boolean Logic (AND, OR, etc.)<li>Multiply / Divide (less common)</ul></ul><li>Instruction Decode Unit (I Unit): Fetches opcode, updates IAR, finds effective address (locate data), sends control to E unit.<ul><li>Address Mode: Instructions on how to determine effective address.<li>Effective Address: Actual location of data; provided by address mode.</ul><li>Execution Unit (E Unit): Executes provided instruction.</ul><h2 id=memory-bus><a href=#memory-bus aria-label="anchor link for memory-bus">##</a> Memory Bus</h2><p><em>The magic that makes the CPU and DRAM talk.</em><ul><li>Address Bus (CPU -> Memory): Carries desired memory address from CPU to memory.<ul><li>64-bit computers "can" address <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msup><mjx-mn class=mjx-n><mjx-c class=mjx-c32></mjx-c></mjx-mn><mjx-script style=vertical-align:.363em><mjx-mn class=mjx-n size=s><mjx-c class=mjx-c36></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mn class=mjx-n><mjx-c class=mjx-c34></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msup><mn>2</mn><mn>6</mn></msup><mn>4</mn></math></mjx-assistive-mml></mjx-container> bytes, but most only implement <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msup><mjx-mn class=mjx-n><mjx-c class=mjx-c32></mjx-c></mjx-mn><mjx-script style=vertical-align:.363em><mjx-mn class=mjx-n size=s><mjx-c class=mjx-c33></mjx-c></mjx-mn></mjx-script></mjx-msup><mjx-mn class=mjx-n><mjx-c class=mjx-c36></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msup><mn>2</mn><mn>3</mn></msup><mn>6</mn></math></mjx-assistive-mml></mjx-container>.</ul><li>Data Bus (CPU &lt;-> Memory): Sends data to the CPU or to the memory, depending on read/write line.<li>Address Valid Line (CPU -> Memory): Must be set for memory to send data over data bus.<li>Read/Write Line (CPU -> Memory): Whether the CPU is writing to memory or the memory is sending to the CPU.<li>Clock Line (CPU -> Memory): Keeps CPU and memory in sync.</ul><h1 id=history><a href=#history aria-label="anchor link for history">#</a> History</h1><p>DOS was less of an OS and more of a monitor. The processes it started had complete control of the computer. DOS would just ask you what you want.<h2 id=software><a href=#software aria-label="anchor link for software">##</a> Software</h2><p>There were three big players: IBM, Motorola, and Intel. IBM was the biggest and there were many others.<p>When the PC age came in, the biggest player IBM bought hardware from Intel and software from Microsoft. <em>Why?</em> It was far cheaper to do since IBM's hardware was focused on high-quality mainframes.<p>Motorola had a 16 bit 6800. They decided to make a huge redesign, the 68000, which was an extremely well designed 32 bit architecture. However, the software was incompatible.<p>Intel had a 16 bit 8080. They decided to make an incremental redesign, the 8086, which was a 32 bit architecture that could only support 20 bits of memory. However, the software was compatible. This ended up making it when. <em>How did they make it work?</em> They used memory segments / blocks to indirect the desired memory address from the actual physical address.<h1 id=architecture-woes><a href=#architecture-woes aria-label="anchor link for architecture-woes">#</a> Architecture Woes</h1><p>Computers are complex things that grow and evolve over time. Here's a chronicle of some of disagreements and compromises that have been made throughout history.<h2 id=memory-segments><a href=#memory-segments aria-label="anchor link for memory-segments">##</a> Memory Segments</h2><p>Memory on the 8086 had 20 bit addresses. However, it only have 16 bit registers. To get around this, we added the concept of segments. <em>Note:</em> Memory segments were a hack to get around limitations.<p>Segments are 16 byte blocks of addresses, where each segment is a 16 bit number. We throw away the smallest 4 bits (or last hex digit). To get the actual address, you multiple the address of the segment by 16 (add a 0 to the right in hex) and add the offset.<pre class="z-code language-nohighlight" data-lang=nohighlight><code class=language-nohighlight data-lang=nohighlight><span class="z-plain z-text"># Data offset
DS = 0x1234
# Memory offset
memory_address = 0x5678
# Actual address
DS + memory_address
0x1234 * 0x10 + 0x5678
0x12340 + 0x5678
0x179b8
</span></code></pre><p>We have four different types of segments:<ul><li>Data segment.<li>Code segment.<li>Stack segment.<li>Extra segment. (Exists only because we used 2 bits to address segments.)</ul><p><em>Why is this bad?</em> It's an extra thing we always have to do, which is slow. We didn't extend the amount of memory a process could have, so if you need that you need to determine what segment you want, where the segment you want is, and then load it in.<p><em>Note:</em> This no longer exists anymore for the most part.<h2 id=endianness><a href=#endianness aria-label="anchor link for endianness">##</a> Endianness</h2><p>Endianness used to be incredibly important when we had 1 byte or otherwise small memory buses. It no longer matters as much, but we are still bound by the legacy decision.<p>Intel machines are little endian, meaning that the least significant byte is stored first in memory. The alternative is big endian, meaning the most significant byte is stored first in memory.<p><em>Why be little endian?</em> When we get large values into the CPU from memory (i.e. more than one byte), the CPU expects the smallest byte first. To prevent jumping around, we store the bytes in memory such that we first see the smallest byte.<p><em>Note:</em> This byte reversal only occurs in memory and not in the CPU.<h1 id=x86-anatomy><a href=#x86-anatomy aria-label="anchor link for x86-anatomy">#</a> x86 Anatomy</h1><h2 id=registers><a href=#registers aria-label="anchor link for registers">##</a> Registers</h2><p>There are 4 general purpose registers in x86, and they are 16 bit (words). You can replace the <code>x</code> with an <code>h</code> to access only the upper half (more significant) half of the register; use <code>l</code> to use the lower half.<ul><li><code>ax</code>: Accumulator. Default for many operations.<li><code>bx</code>: Base.<li><code>cx</code>: Count.<li><code>dx</code>: Data.</ul><p>There are also a few special purpose registers in x86, also 16 bit registers.<ul><li><code>SP</code>: Stack pointer. Location of top of stack.<li><code>BP</code>: Base pointer. Location of bottom of stack.<li><code>IP</code>: Instruction pointer.<li><code>SI</code>: Source index. For string operations.<li><code>DI</code>: Destination index. For string operations.</ul><h2 id=status-flags-condition-codes><a href=#status-flags-condition-codes aria-label="anchor link for status-flags-condition-codes">##</a> Status Flags / Condition Codes</h2><p>All status flags give you status on the last operation performed. <em>Except there are some that don't set the flags.</em><ul><li><code>SF</code>: Sign flag. 1 means negative. 0 means positive. <em>This only looks at the most significant bit.</em><li><code>ZF</code>: Zero flag. 1 means last operation was zero. 0 means last operation was not zero.<li><code>OF</code>: Overflow flag. 1 means overflow. 0 means no overflow. It is set when the sign of the two incoming numbers are the same but the result is not.<ul><li><em>Checks signed overflow.</em></ul><li><code>CF</code>: Carry flag. 1 means there was a carry. 0 means there was not.<ul><li><em>Checks unsigned overflow.</em></ul></ul><h1 id=dos-anatomy><a href=#dos-anatomy aria-label="anchor link for dos-anatomy">#</a> DOS Anatomy</h1><p>DOS was written for the 8086, which could only address 1MiB of RAM. DOS further limits this to 640KiB for user programs, of this ~100KiB is used by DOS itself. The remaining 384KiB are reserved for the ROM, BIOS, and memory-mapped for IO.<p>The display happens to be assigned to addresses <code>Bx xxx</code>. To update the display, you just write to that part of memory and the hardware handles the rest.<h1 id=assembly><a href=#assembly aria-label="anchor link for assembly">#</a> Assembly</h1><p>Every line of assembly is like the following. You don't always have <code>dest</code> or <code>source</code> for an opcode. You can always have a label or comment, even if you don't have an opcode.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-comment"> ;comment</span>
</span></code></pre><ul><li><code>label:</code> An identifier that can be used for GOTOs (or other) later.<li><code>opcode</code> Short, human-readable name for an instruction.<li><code>dest</code> What the instruction operates on.<li><code>source</code> What the instruction gets its data from.<li><code>comment</code> A command. Completely ignored by assembler.</ul><p>There are a few limitations / things you have to get right:<ul><li><code>dest</code> and <code>source</code> must be the same size.<li>You cannot have two memory references.</ul><p><em>Note:</em> In this class, every line needs a comment and you put block comments in front of sections.<p>You can also declare data in memory like the following.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">(</span><span class="z-assembly z-function z-directive z-support">db</span><span class="z-assembly z-function z-entity z-name">|</span><span class="z-assembly z-function z-directive z-support">dw</span><span class="z-assembly z-function z-entity z-name">)</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-comment"> ; comment</span>
</span></code></pre><ul><li><code>varname</code>: An identifier that can be used for later references.<ul><li>Future references must be wrapped in square brackets (e.g. <code>[varname]</code>).</ul><li><code>db</code>: Declare data to be bytes.<li><code>dw</code>: Declare data to be words (2 bytes).<li><code>value</code>: An immediate value.</ul><h2 id=address-mode><a href=#address-mode aria-label="anchor link for address-mode">##</a> Address Mode</h2><p>The address mode describes how the machine should locate the value. Here's a list of ones:<ul><li>Register Direct: Get value from address.<ul><li>Can always be source and destination.</ul><li>Immediate: Hard code a value into the binary and use that.<ul><li>Can always be source but never destination.</ul><li>Memory Direct: Get value from memory.<ul><li>Can always be source and destination, unless memory direct is both source and destination.</ul><li>List / Structure: You use a register (<code>si</code>, <code>di</code>, <code>bx</code>, or <code>bp</code>) to indirectly address some piece of memory.<ul><li>Valid Combinations:<ul><li>Base or index optionally with displacement.<li>Base and index optionally with displacement.</ul><li>Default Segments: You can force the segment you want by prefixing the index with a certain segment register (i.e. <code>cs:[si]</code>).<ul><li>Data Segment: <code>si</code>, <code>di</code>, <code>bx</code>.<li>Stack Segment: <code>bp</code>.</ul></ul></ul><h2 id=instructions-opcodes><a href=#instructions-opcodes aria-label="anchor link for instructions-opcodes">##</a> Instructions / Opcodes</h2><ul><li><code>mov</code>: Copies source into destination.<ul><li>Cannot move immediate into segment register.<li>Cannot move between segment registers.<li>Does not set condition code.</ul><li><code>add</code>: <code>dest += source</code>.<li><code>sub</code>: <code>dest -= source</code>.<ul><li>Due to the way hardware implements subtraction (inverting and then adding), the carry flag "shouldn't" be set the way you expect. However, Intel engineers made it so it is set how you'd expect.</ul><li><code>inc</code>: Increments <code>dest</code>, without setting the carry flag. It doesn't set the carry flag because inc is most often used for iteration, so you may want to keep the carry information from a previous loop. It's also unlikely that you'll has signed overflow from incrementing.<li><code>cmp</code>: <code>dest - source</code>, throwing away values but sets flags.<li><code>jmp</code>: Unconditional jump to <code>dest</code> as an instruction address. This normally jumps to a label or an offset, which are things provided by the assembler.<ul><li>Just slaps <code>dest</code> into the instruction pointer (<code>IP</code>).</ul><li>Conditional Jumps: There a large collection of different opcodes that check all the different flags we have. To use them, you must first do some arithmetic (normally <code>cmp</code>) and then use the appropriate conditional jump. When the condition is true, they jump; otherwise, they fall through.<ul><li>You can look on the class website (notes 6-16).</ul><li><code>int</code>: Triggers interrupt identified by <code>dest</code>. <code>21h</code> is the <code>dest</code> for DOS syscalls. DOS looks for the syscall ID in <code>ah</code> and the arguments in <code>al</code>.<ul><li><strong>NOTE:</strong> All DOS syscalls may use <code>ax</code> register. This is actually the cause of the <em>NT bug</em>, which was when a bunch of assembly programs broke when NT started using the <code>ax</code> register for the write syscall and didn't previously.</ul><li><code>loop</code>: Decrement <code>cx</code> and jump if <code>cx</code> isn't zero. Preserves condition codes.</ul><pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">db</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">?</span><span class="z-assembly z-function z-entity z-name">?</span><span class="z-assembly z-function z-entity z-name">?</span><span class="z-assembly z-comment"> ; speed in mph (unsigned byte)</span>

<span class="z-assembly z-comment">; Go to trouble if speed is greather than 55mph</span>
<span class="z-assembly z-control z-keyword">cmp</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-source">]</span><span class="z-assembly z-source">,</span><span class="z-assembly z-character z-constant z-decimal">55</span><span class="z-assembly z-comment"> ; Check speed (speed - 55)</span>
<span class="z-assembly z-control z-keyword">ja</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-comment">  ; ja because unsigned ></span>
</span></code></pre><h3 id=syscalls><a href=#syscalls aria-label="anchor link for syscalls">###</a> Syscalls</h3><p>DOS decided to make <code>21h</code> be the interrupt for DOS syscalls. There are a bunch of syscalls, but all of them send/receive information via the <code>al</code> register and are identified in the <code>ah</code> register.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-comment">; Read character from stdin into al register</span>
<span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ah</span><span class="z-assembly z-source">,</span><span class="z-assembly z-character z-constant z-decimal">8</span>
<span class="z-assembly z-control z-keyword">int</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-hexadecimal">21h</span>
<span class="z-assembly z-comment">; Write character to stdout</span>
<span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ah</span><span class="z-assembly z-source">,</span><span class="z-assembly z-character z-constant z-decimal">2</span>
<span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">al</span><span class="z-assembly z-source">,</span><span class="z-assembly z-string">'a'</span>
<span class="z-assembly z-control z-keyword">int</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-hexadecimal">21h</span>
</span></code></pre><h2 id=immediates><a href=#immediates aria-label="anchor link for immediates">##</a> Immediates</h2><p>The machine has no concept of negatives. Instead, it must be managed by the programmer.<p>Our assembly has no special marker for immediates. You just write a number. You can prepend the number with a <code>-</code> to mark it as two's complement negative. You can append the number with a <code>h</code> to mark it as hex.<p>If you have multiple immediates separated by commas, they become a list.<p>If you wrap a character with <code>'</code>, then it gets encoded to ASCII. If you wrap a string with <code>'</code>, then it gets encoded to ASCII as a list.<h2 id=directives><a href=#directives aria-label="anchor link for directives">##</a> Directives</h2><p>Directives are commands to the assembler, not the machine. All directives in this class look like <code>.name</code>.<ul><li><code>.model</code>: What memory model for the assembler to use. For DOSBOX, we use <code>.model small</code>.<li><code>.8086</code>: Only use 8086 instructions.<li><code>.stack</code>: How many bytes for the stack segment to hold. For DOSBOX, we use <code>.stack 256</code>.<ul><li>You could manually change the stack segment register, but that's more complicated.</ul><li><code>.data</code>: Marks start of data segment. This is where you can define the data as described earlier. <em>Optional.</em><li><code>.code</code>: Marks start of code segment. This is where you can define the instructions as described earlier. Technically optional, but why would you not want it?</ul><h2 id=casting><a href=#casting aria-label="anchor link for casting">##</a> Casting</h2><p>To down-cast numbers, you just throw away the bits. To up-cast unsigned numbers, you just put zeros in front. To up-cast signed numbers, you extend the sign bit.<p>The hardware doesn't provide a direct instruction for unsigned up-casting because is easy. Since signed up-casting is more difficult, there is an instruction to <em>convert byte to word</em> (<code>cbw</code>), but it only works on <code>ax</code>.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-comment">; Signed Up-Casting</span>
<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span>
<span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">db</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">255</span>
<span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">db</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">1</span>
<span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">dw</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">0</span>
<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">e</span>
<span class="z-assembly z-comment"> ; [c] = [a] + [b]</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">al</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">xor</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ah</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ah</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bl</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">xor</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bh</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bh</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">add</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bx</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-source">]</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span>
</span></code></pre><pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-comment">; Unsigned Up-Casting</span>
<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span>
<span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">db</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">-</span><span class="z-assembly z-character z-constant z-decimal">1</span>
<span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">db</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">2</span>
<span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">dw</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">0</span>
<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">e</span>
<span class="z-assembly z-comment"> ; [c] = [a] + [b]</span>
<span class="z-assembly z-comment"> ; Cast [a] to word</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">al</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">cbw</span><span class="z-assembly z-comment"> ; ax = FF FF</span>
<span class="z-assembly z-comment"> ; We shift [a] to bx since cbw only works on ax</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bx</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span>
<span class="z-assembly z-comment"> ; Cast [b] to word</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">al</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">cbw</span>
<span class="z-assembly z-comment"> ; Add them</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">add</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bx</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-source">]</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span>
</span></code></pre><h2 id=basic-example><a href=#basic-example aria-label="anchor link for basic-example">##</a> Basic Example</h2><p>The first thing you do (normally) in your assembly program is set the data segment and sometimes the extra segment. <em>The code segment and stack segment are set by the OS.</em><p>Identifiers that start with <code>@</code> are "injected" into the code by the OS loader at load time.<p><em>Note:</em> DOS makes <code>21h</code> a syscall. The identifier for the desired syscall goes in <code>ah</code> and the return is in <code>al</code>.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span>
<span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">db</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">10</span>
<span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">db</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">55</span>
<span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">db</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">0</span>

<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">e</span>
<span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-comment">  ; Set up the data segment (DS). We cannot move</span>
<span class="z-assembly z-comment">  ; immediates into segment registers per the</span>
<span class="z-assembly z-comment">  ; machine design.</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">@</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ds</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span>

<span class="z-assembly z-comment">  ; C = A + B</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">al</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">add</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">al</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-source">]</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">al</span>

<span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">x</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-comment">  ; syscall: ah = service code: al = return code</span>
<span class="z-assembly z-comment">  ; 4c = terminate</span>
<span class="z-assembly z-comment">  ; 00 = 0 return code</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-hexadecimal">4c00h</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">int</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-hexadecimal">21h</span>

<span class="z-assembly z-comment">; Mark end of source code and give it address</span>
<span class="z-assembly z-comment">; of first instruction. This is not an</span>
<span class="z-assembly z-comment">; instruction, although it looks like it.</span>
<span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">t</span>
</span></code></pre><h2 id=indirect-addressing><a href=#indirect-addressing aria-label="anchor link for indirect-addressing">##</a> Indirect Addressing</h2><p>You can use the following registers as index/pointer registers. All others are invalid because of hardware limitations.<ul><li><code>si</code>: Source index. In data segment. Program data.<li><code>di</code>: Destination index. In data segment. Program data.<li><code>bx</code>: Base register. In data segment. Program data.<li><code>bp</code>: Base pointer. In stack segment. Subroutine arguments.</ul><p>Here's a quick example.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span>
<span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">dw</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-comment"> ; Values to sum</span>

<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">e</span>
<span class="z-assembly z-comment">; let mut sum = 0;</span>
<span class="z-assembly z-comment">; for i in 0..9 { sum += list[i] }</span>
<span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-comment"> ; set up data segment</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">@</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ds</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span>

<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">xor</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-comment"> ; ax = 0</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">cx</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">10</span><span class="z-assembly z-comment"> ; cx = 0</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">si</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">f</span><span class="z-assembly z-function z-entity z-name">f</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-comment">  ; si = &list</span>
<span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">add</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-parameter z-register z-variable">si</span><span class="z-assembly z-source">]</span><span class="z-assembly z-comment"> ; ax += *si</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">add</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">si</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">2</span><span class="z-assembly z-comment"> ; si++ (because dw has a size of 2)</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">loop</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-comment"> ; do { ... } while (--cx != 0)</span>
</span></code></pre><p>You <strong>must</strong> be careful with how you compare indirect addresses with immediates (and anything else) because <strong>the assembler cannot tell</strong> whether you want to treat the indirect address as pointer to a byte or pointer to a word. (This ambiguity doesn't exist for using direct addresses with things of known size.) To get around this, you prefix the indexing with <code>word ptr</code> or <code>byte ptr</code>. This just tells the assembler what instruction to produce.<h2 id=subroutines><a href=#subroutines aria-label="anchor link for subroutines">##</a> Subroutines</h2><p>Subroutines encompass procedures, functions, and methods.<p>Compilers has <strong>linkage conventions</strong> (or ABI), where they expect subroutines to be called in a certain way and to be set up in a certain way. You must write your subroutines or subroutine calls following these conventions if you want a high level language (HLL) to be able to call the subroutine or for you to be able to call a HLL's subroutines.<p><em>Why use subroutines?</em> Subroutines are self-contained and reusable, which is great software development.<p><em>Why not use subroutines?</em> Calling subroutines can be more expensive than just in-lining the subroutine and you have to develop conventions, which increases complexity. (Compilers can easily mitigate this.)<p>There's a few common protocols. They're mostly split up by different concerns that can be combined freely.<ul><li>State Management:<ul><li>Subroutine stores, the called subroutine saves and restores all registers it modifies except for its returns.<li>Caller stores, the caller of the subroutine saves all the registers it cares about and returns them.<li>Efficient but easy to mistake, the caller saves only the live registers that the subroutine modifies.</ul><li>Parameter Passing:<ul><li>Use registers, simple but limited.<li>Share global variables, incredibly hard to track. <strong>Do not use.</strong><li>Pass on stack, highly recommended and used by most HLLs.</ul></ul><p>Since x86 is a CISC, it has a <code>call</code> and <code>ret</code> instructions. <code>call</code> pushes the next instruction's address onto the stack and jumps to the given label. <code>ret</code> pops a word word off of the stack and jumps to that as if it were the address of an instruction. (Normally you use <code>call</code> and then <code>ret</code>.)<p>Similarly, it has a <code>push</code> instruction which puts a value on the stack and updates the stack pointer (<code>sp</code>). You could do this manually, but it is slower.<h3 id=multiple-files><a href=#multiple-files aria-label="anchor link for multiple-files">###</a> Multiple Files</h3><p>As you know, programming everything in one file can get really annoying. However, when we have a subroutine defined in a separate file, how can the assembler find it when its assembling our file?<p><em>It can't!</em> The trick is we have to say that the subroutine's label is external via <code>extern &lt;LABEL></code> in the main file and mark the labels as <code>public &lt;LABEL></code> in the subroutine file. When the assembler sees this, it will generate a symbol table and the linker will make sure that link all the object file's symbol table's together. If it can't find some symbols, it fails, but if it can find all the symbols then it properly links them all together.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-comment">; main.asm</span>
<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">l</span>
<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-character z-constant z-decimal">8086</span>
<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">k</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">256</span>

<span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">x</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">e</span>

<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span>
<span class="z-assembly z-function z-entity z-name">f</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-directive z-support">dw</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">8</span>

<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">e</span>
<span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">@</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ds</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span>

<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">cx</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">10</span><span class="z-assembly z-comment"> ; Some personal data</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">6</span><span class="z-assembly z-comment"> ; Arguments</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">push</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">cx</span><span class="z-assembly z-comment"> ; Save cx</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">call</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">e</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">pop</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">cx</span><span class="z-assembly z-comment"> ; Recover cx</span>

<span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">x</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-hexadecimal">4c00h</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">int</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-hexadecimal">21h</span>

<span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">t</span>
</span></code></pre><pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-comment">; subroutine.asm</span>
<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">l</span>
<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-character z-constant z-decimal">8086</span>
<span class="z-assembly z-comment">; DON'T REDEFINE .stack</span>

<span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">e</span>

<span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">cx</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">123</span><span class="z-assembly z-comment"> ; Trash cx</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">5</span><span class="z-assembly z-comment"> ; Return value</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">ret</span>

<span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-comment"> ; NO START ROUTINE</span>
</span></code></pre><h3 id=putting-assembly-and-hlls-together><a href=#putting-assembly-and-hlls-together aria-label="anchor link for putting-assembly-and-hlls-together">###</a> Putting Assembly and HLLs Together</h3><p>To write assembly for a high level language (or a specific compiler), you have to conform to the language's API. This is because the compiler generates things in a certain way and the assembly needs to look like the compiler expects.<p>For C, subroutines are called by pushing arguments to the stack (in reverse order) and functions with name <code>&lt;name></code> become subroutines with name <code>_&lt;name></code> (i.e. they prefix the name with an underscore). Additionally, the callee is responsible for saving <code>bp</code>, <code>si</code>, <code>di</code>, <code>ss</code>, and <code>ds</code> while the caller is responsible for all others.<p><em>Why does C specify that you should push the arguments in reverse?</em> It is because C functions can have variadic arguments.<p>For the subroutines to get the arguments off the stack, the subroutine has to look back into the stack. This is done by copying the stack pointer to the base pointer and looking up a known offset to the subroutine. <em>If you're not pushing anything in your subroutine, you don't actually need to copy the stack pointer.</em><pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-comment">; int rc = asmprint('x', 5);</span>
<span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-comment">  ; Push the arguments onto the stack. C does</span>
<span class="z-assembly z-comment">  ; this in the opposite order because it means</span>
<span class="z-assembly z-comment">  ; adding arguments</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">5</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">push</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">al</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">120</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">push</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span>
<span class="z-assembly z-comment">  ; Make the call</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">call</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">_</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">t</span>
<span class="z-assembly z-comment">  ; Pop the arguments you pushed onto the stack</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">add</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">sp</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">4</span>
<span class="z-assembly z-comment">  ; Retrieve the return value, returned in ax</span>
<span class="z-assembly z-comment">  ; by convention</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-source">]</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span>

<span class="z-assembly z-function z-entity z-name">_</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">push</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bp</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bp</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">sp</span>
<span class="z-assembly z-comment">  ; 4 to skip the IP pushed by call</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">dl</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-parameter z-register z-variable">bp</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">+</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">4</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-comment">  ; 4 to skip the IP pushed by call</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">cx</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-parameter z-register z-variable">bp</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">+</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">6</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ah</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">2</span><span class="z-assembly z-comment"> ; Plan to read</span>
<span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">_</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">int</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-hexadecimal">21h</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">loop</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">_</span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">p</span>

<span class="z-assembly z-comment">  ; Set return value</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">ax</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">0</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">pop</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bp</span>
<span class="z-assembly z-comment">  ; We'd have to pop stuff off the stack if we</span>
<span class="z-assembly z-comment">  ; had pushed</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-control z-keyword">ret</span>
</span></code></pre><p><strong>Security Note:</strong> Whenever you make a call to a subroutine within a subroutine your arguments are visible to the subroutine.<p><em>Note:</em> Since 64-bit Intel chips released 8 general purpose registers, C started passing arguments in these registers. It tried to put the first 6 arguments in the double word registers.<h2 id=stack><a href=#stack aria-label="anchor link for stack">##</a> Stack</h2><p>On the 8086, the stack grows downwards and by units in words. The stack pointer (<code>sp</code>) points to the start of the stack, getting decremented by 2 whenever its pushed and incremented by 2 whenever its pushed.<p>If we want <em>re-entrant</em> code (i.e. the subroutine can be called as many times as you want concurrently), you aren't allowed to store any values explicitly in the data segment. (Imagine if you made a recursive call to a function that stores values in the data segment.) To get around this, you put local variables in the stack, at a certain offset down from the current stack frame (normally <code>bp</code>).<h1 id=anatomy-of-machine-code><a href=#anatomy-of-machine-code aria-label="anchor link for anatomy-of-machine-code">#</a> Anatomy of Machine Code</h1><p><em>Note:</em> Use the table in the course notes for the test.<p>On the 8086, instructions are variable sized and can be 1 to 6 bytes. Here's the breakdown. Each block is a byte and the numbers within the bytes are bits. You don't need every byte for all instructions.<figure><img src=machine_code_anatomy.png><figcaption><p>Anatomy of x86 Instruction</figcaption></figure><ul><li>Code (1 byte): What is actually being executed. Always needed.<ul><li>opcode: What to execute.<li>d: Data direction (0 = reg rc, 1 = reg dest).<li>w: Data size (0 = byte, 1 = word).</ul><li>Addr (1 byte): Expands opcodes and describes operands. Needed for certain opcodes (see table).<ul><li>mod: Mode.<li>reg: Register or special code.<li>r/m: Register/memory.</ul><li>Disp (2 bytes): Memory offset for variables. Needed if you have a memory operand.<li>Data (2 bytes): Immediate data. Needed if you have an immediate operand. If you have byte immediate memory, only use the low byte.</ul><p><em>Note:</em> <code>al</code> is the byte accumulator. <code>ax</code> is the word accumulator.<h1 id=boolean-algebra-and-computer-hardware><a href=#boolean-algebra-and-computer-hardware aria-label="anchor link for boolean-algebra-and-computer-hardware">#</a> Boolean Algebra and Computer Hardware</h1><p>There are certain bitwise operations that are <strong>atomic</strong>. That means that they can be used to construct every other operation (e.g. AND, OR, etc.), which can then be used to generate addition, subtraction, and everything! NAND is the standard atomic operation.<p>x86 has boolean instruction / bitwise operations:<ul><li><code>not ax</code><li><code>and ax, bx</code><li><code>or ax, bx</code><li><code>xor ax, bx</code></ul><p>x86 also has shifts, both left and right and both arithmetic and logical. Arithmetic fills in with the sign bit on the left. Logical always fills with zeros. Both of them shift the bit out into the carry. You should use <em>arithmetic</em> for signed numbers and <em>logical</em> for unsigned numbers.<ul><li><code>shl ax</code>: Shift logical left. <em>Multiply by 2.</em><li><code>shr ax</code>: Shift logical right. <em>Divide by 2.</em><li><code>sal ax</code>: Shift arithmetic left. (Actually same as logical left! Just clearer to people)<li><code>sar ax</code>: Shift arithmetic right.</ul><p>All shifts always round down, meaning <code>sar -5</code> yields -3, because -5/2 is -2.5. This means constantly arithmetically shifting right a negative number will yield -1.<p>Similar to shifts are rotations. They are identical to shifts except that the bit shifted out is the same as the bit shifted in. <em>The carry bits are still set the same.</em> There is no arithmetic vs logical rotating. It's just rotating.<h1 id=arm-assembly><a href=#arm-assembly aria-label="anchor link for arm-assembly">#</a> ARM Assembly</h1><p>ARM (Advanced RISC Machine) is designed and licensed by a British company ARM Holdings. They don't actually manufacture any chips, just design them and license out the designs.<p>ARM processors are widely in embedded contexts due to their low power usage. Because embedded systems can vary so widely, there are variants on ARM assembly designed to make certain tasks easier.<h2 id=general-design><a href=#general-design aria-label="anchor link for general-design">##</a> General Design</h2><p>ARM is a load and store machine. That is, all data processing is done in registers, so to manipulate memory variables you must load them into a register and then store them out once you're done.<p>All instructions are 32 bits in length and almost all instructions execute in a single cycle.<p>Instructions can be conditionally executed without jumps. That is, only perform this when this.<p>Instructions can optionally set the condition codes. It is up the developer / compiler to decide.<h2 id=programming-model><a href=#programming-model aria-label="anchor link for programming-model">##</a> Programming Model</h2><p>Memory address space is 4 GiB (i.e. 32 bit address space) and there are three data sizes, listed below, that can both either be unsigned or signed two's complement. There are also 16 general purpose registers, 3 of which have special meaning (but can still be manipulated normally). There's an additional status register that stores the flag.<ul><li>Data Sizes:<ul><li>Byte: 8 bits.<li>Halfword: 16 bits.<li>Word: 32 bits.</ul><li>Registers:<ul><li>r0, ..., r12: General purpose.<li>r13 (SP): Stack pointer. (Same as in x86 terms.)<li>r14 (LR): Link register. Where the return address to a subroutine is stored. In x86 all return addresses are on the stack. In ARM return addresses can be put on the stack in software (and often are), but for the machine it has to be in LR.<li>r15 (PC): Program counter. (Instruction pointer in x86 terms.)<li>Status Register: Where execution flags are stored. Here's a brief listing. You can find more on the class website.<ul><li>N: Sign. (0 = positive, 1 = negative)<li>Z: Zero. (0 = zero, 1 = not zero)<li>C: Carry.<ul><li>On addition, this acts the same way as x86, where the carry flag is just the carry out of the addition.<li>On subtraction, this is the opposite of the x86. The borrow flag does not match real subtraction and instead matches the complementary addition.</ul><li>V: Signed overflow. (0 = didn't occur, 1 = did occur)</ul></ul></ul><h2 id=instructions><a href=#instructions aria-label="anchor link for instructions">##</a> Instructions</h2><h3 id=load-and-store><a href=#load-and-store aria-label="anchor link for load-and-store">###</a> Load and Store</h3><p>Loading and storing is done much differently than in x86, where it was just <code>mov</code>. Here's a list of some of the different operations. <code>rd</code> is the destination, <code>rn</code> is the first source, and <code>rm</code> is the second store. Almost every load has a corresponding store, except for loading constants of course.<p><em>Note:</em> We only list <code>ldr</code> and <code>str</code> here. These operate on unsigned words. There are different versions of load and store with different suffixes that operate on halfwords, bytes, signed, etc.<ul><li>Loads: Load a value into <code>rd</code>.<ul><li><code>ldr rd, =var</code>: Assigns address of variable.<li><code>ldr rd, =const</code>: Assigns constant.<li><code>ldr rd, [rn]</code>: Assigns value pointed to by <code>rn</code>.<li><code>ldr rd, [rn, rm]</code>: Assigns value pointed to by <code>rn + rm</code> (sum of registers).<li><code>ldr rd, [rn, #n]</code>: Assigns value pointed to by <code>rn + #n</code> (register with offset).<li><code>ldr rd, [rn], #n</code>: Assigns value pointed to by <code>rn</code> and then post increment <code>rn</code> by <code>#n</code>. (Useful for iteration.)</ul><li>Stores: Store the value of <code>rd</code> into something. <strong>The destination is the second operand.</strong><ul><li><code>str rd, [rn]</code>: Store into memory pointed to by <code>rn</code>.<li><code>str rd, [rn, rm]</code>: Store into memory pointed to by <code>rn + rm</code> (sum of registers).<li><code>str rd, [rn, #n]</code>: Store into memory pointed to by <code>rn + #n</code> (register with offset).<li><code>str rd, [rn], #n</code>: Store into memory pointed to by <code>rn</code> and then post increment <code>rn</code> by <code>#n</code>. (Useful for iteration.)</ul></ul><h3 id=conditional-execution><a href=#conditional-execution aria-label="anchor link for conditional-execution">###</a> Conditional Execution</h3><p>In ARM, many instructions can be executed conditionally. To make an instruction conditionally executed in assembly, you must prefix your instruction's mnemonic with the conditional flag that you want.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-comment">; calc abs(r4)</span>
<span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">0</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">#</span><span class="z-assembly z-character z-constant z-decimal">0</span><span class="z-assembly z-comment"> ; Set r0 to 0. Necessary to negate r4</span>
<span class="z-assembly z-control z-keyword">cmp</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">4</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">#</span><span class="z-assembly z-character z-constant z-decimal">0</span><span class="z-assembly z-comment"> ; Test value in r4</span>
<span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">u</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">4</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">0</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">4</span><span class="z-assembly z-comment"> ; if neg, r4 = 0 - r4</span>
</span></code></pre><p>You can look at the class notes to see what specific instructions can be executed conditionally and what the suffixes are for each condition code.<p>For instructions that can optionally set the condition codes (e.g. <code>add</code>, <code>sub</code>), you must suffix the instruction mnemonic with <code>s</code> if you want to update the condition codes. When you combine this suffix with conditional execution, you put the <code>s</code> after the conditional execution suffix.<p><em>Why would you want to do this?</em> It improves performance for pipelined machines. In a pipelined machine, instruction execution is divided into stages where instructions are passed from stage to stage. This allows multiple instructions to be executing in parallel. In pipelined machines, conditional jumps cause "bubbles" in the pipeline, because you can't determine whether you should jump or not until that instruction has gone through the entire pipeline. This can be mitigated using speculative execution, but that still has a cost if you're wrong.<p>With conditional execution, there is no pipeline draining and much less pipeline "bubbles". Suppose we have a pipeline with 4 stages. If we did a conditional jump, we'd have a bubble of 4 instructions if we used a conditional jump. With conditional execution, we have a bubble of 1 instruction. (Well, really the instruction would just happen to be "wasted". We'd still work on it.) And we have no bubble at all if we actually execute the instruction.<p><em>Note:</em> These pipeline bubbles occur when the machine starts the pipeline with something it didn't need and must subsequently "drain" the pipeline if it realizes it was wrong.<h3 id=immediates-1><a href=#immediates-1 aria-label="anchor link for immediates-1">###</a> Immediates</h3><p>Immediates have some weird rules about them in ARM. Since all instructions are 32-bits and some bits are needed for the opcode, destination register, and other things, not all 32 bits of the instruction are available for immediates. In fact, only 12 bits are available.<p>To extend the range of immediates allowed, ARM splits up the space for immediates into 8 bits for the value and 4 bits the rotation amount. When accessing an immediate, the machine reads in the 8 bit value and then rotates it right (<code>ROR</code>) two times the rotation amount.<p>This means any 0-255 value can be generated with a rotation amount of 4. Any multiple of 4 less than <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c34></mjx-c></mjx-mn><mjx-mo class=mjx-n space=3><mjx-c class=mjx-c2217></mjx-c></mjx-mo><mjx-mn class=mjx-n space=3><mjx-c class=mjx-c32></mjx-c><mjx-c class=mjx-c35></mjx-c><mjx-c class=mjx-c35></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>4</mn><mo>∗</mo><mn>255</mn></math></mjx-assistive-mml></mjx-container> can be generated using a rotation amount of <code>F</code> (i.e. 30), because rotating a 32 bit field 30 times right is equivalent to rotating left 2 times which is equivalent to multiplying by 4. These rules follow similarly for other rotation amounts. (It's kinda annoying to think about rotating right, so normally we just consider rotating left and convert the value.)<p><em>Why did they make it this complicated rule?</em> It vastly extends the range of immediates allowed, means every immediate you want possible to create out of 2 immediates, is really easy to do in hardware, and assemblers and compilers had gotten sophisticated enough at the time of ARM to understand the rules.<p>Okay, well, how do assemblers handle this? If you do something like <code>ldr r0, =999</code>, the assembler will create a memory variable containing <code>999</code> and then convert that instruction into a load from memory. If you do something like <code>add r2, r1, #999</code>, you're just told you can't do that. <em>Why doesn't the assembler handle this case?</em> Because you need an additional instruction to handle this and if the assembler generated additional instructions from each machine instruction then it is no longer a one-to-one mapping, which is valuable for assembly.<h3 id=subroutines-1><a href=#subroutines-1 aria-label="anchor link for subroutines-1">###</a> Subroutines</h3><p>ARM provides several instructions for ergonomically dealing with subroutines. In general, storing the return address is called <strong>linking</strong> and jumping to different addresses is called <strong>branching</strong>.<ul><li><code>bl label</code>: Branch and link to label. Saves the next <code>ip</code> as <code>lr</code> and then sets <code>pc</code> to <code>label</code>.<ul><li>Basically <code>call</code> from x86.<li>This can be conditionally executed.</ul><li><code>stmdb sp!, {regs..., lr}</code>: Store multiple decrement before use. The <code>!</code> causes the stack pointer <code>sp</code> to be updated. It stores the registers in brackets on the stack and decrements the stack pointer before it is used.<ul><li>Make sure that the link register <code>lr</code> is the return address.</ul><li><code>ldmia sp!, {regs..., pc}</code>: Loads multiple increment after use. The <code>!</code> causes the stack pointer <code>sp</code> to be updated. It loads values off the stack into the registers in brackets and then increments the stack pointer after it is used.<ul><li>Make sure that the program counter <code>pc</code> is the last address so we jump back to the link register.</ul></ul><pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">1</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">=</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-comment">  ; r1 points to n</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">0</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">1</span><span class="z-assembly z-source">]</span><span class="z-assembly z-comment">  ; r0 = n</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">bl</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">q</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-comment">  ; call subroutine</span>

<span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">q</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">:</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">b</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">sp</span><span class="z-assembly z-function z-entity z-name">!</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">{</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">1</span><span class="z-assembly z-source">-</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">3</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">}</span><span class="z-assembly z-comment">  ; save r1-r3 and</span>
<span class="z-assembly z-comment">  ; link regiter</span>

<span class="z-assembly z-comment">  ; Trash the registers</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">1</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">=</span><span class="z-assembly z-character z-constant z-decimal">27</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">2</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">=</span><span class="z-assembly z-character z-constant z-decimal">11</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">3</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">=</span><span class="z-assembly z-character z-constant z-decimal">100</span>
<span class="z-assembly z-comment">  ; Load the hardcoded result</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">0</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">=</span><span class="z-assembly z-character z-constant z-decimal">25</span>

<span class="z-assembly z-comment">  ; restore r1-r3, load the pc with the original</span>
<span class="z-assembly z-comment">  ; link register</span>
<span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">m</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-parameter z-register z-variable">sp</span><span class="z-assembly z-function z-entity z-name">!</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">{</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">1</span><span class="z-assembly z-source">-</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">3</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">}</span><span class="z-assembly z-comment">  ;</span>

<span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">a</span>
<span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-directive z-support">word</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">625</span>
<span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-directive z-support">word</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">0</span>
</span></code></pre><h3 id=x86-like-instructions><a href=#x86-like-instructions aria-label="anchor link for x86-like-instructions">###</a> x86-like Instructions</h3><p>These instructions have strong parallels to ones in x86, so we won't dedicate an entire section to each of them.<ul><li>Move: Move is much more limited in ARM. It can only deal with registers and (limited) immediates. You'll generally don't want to use these because most assemblers only have the sophisticated immediate resolving for <code>ldr</code>. Also, you should rarely be copying registers around.<ul><li><code>mov rd, rn</code>: Copy <code>rn</code> into <code>rd</code>.<li><code>mov rd, #n</code>: Move limited constant <code>#n</code> into <code>rd</code>.</ul><li>Arithmetic: Unlike in x86, the destination doesn't need to be a source. In ARM, we can "save" the variables if we'd like.<ul><li><code>add rd, rn, rm</code>: <code>rd = rn + rm</code>.<li><code>add rd, rn, #n</code>: <code>rd = rn + #n</code>.<li><code>sub rd, rn, rm</code>: <code>rd = rn - rm</code>.<li><code>sub rd, rn, #n</code>: <code>rd = rn - #n</code>.<li><code>cmp rd, rn</code>: Calculates <code>rd - rn</code> and sets condition code.<li><code>cmp rd, #n</code>: Calculates <code>rd - #n</code> and sets condition code.</ul></ul><h2 id=data-format-and-labels><a href=#data-format-and-labels aria-label="anchor link for data-format-and-labels">##</a> Data Format and Labels</h2><p><em>Note:</em> These are specifics of ARMSim syntax, but ARMSim syntax is closely related to other assembler's syntax (e.g. GNU Assembler), so this should be closely or direcly applicable.<p>In ARMSim, data declarations and label declarations both end in a colon. Here is some example data declarations<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">1</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">k</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">4</span><span class="z-assembly z-comment">  ; Reserve 4 bytes</span>
<span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">2</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-directive z-support">word</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">1000</span><span class="z-assembly z-comment">  ; 32 bit word</span>
<span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">3</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-directive z-support">word</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-hexadecimal">0x000003e8</span><span class="z-assembly z-comment">  ; hex</span>
<span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">4</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">h</span><span class="z-assembly z-function z-entity z-name">w</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">555</span><span class="z-assembly z-comment">  ; 16 bit half word</span>
<span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">5</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-directive z-support">byte</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-decimal">10</span><span class="z-assembly z-comment">  ; 8 bit byte</span>
<span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">6</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-directive z-support">byte</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">-</span><span class="z-assembly z-character z-constant z-decimal">10</span>
<span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">7</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">z</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-string">"ABC"</span><span class="z-assembly z-comment">  ; Null-terminated ASCII string</span>
<span class="z-assembly z-function z-entity z-name">v</span><span class="z-assembly z-function z-entity z-name">8</span><span class="z-assembly z-function z-entity z-name">:</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">c</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name">i</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-string">"DEF"</span><span class="z-assembly z-comment">  ; ASCII string</span>
</span></code></pre><p>Like in MASM, we can define immediate aliases (basically constant numbers) using the following syntax.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-function z-entity z-name">.</span><span class="z-assembly z-function z-directive z-support">equ</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-function z-entity z-name">S</span><span class="z-assembly z-function z-entity z-name">W</span><span class="z-assembly z-function z-entity z-name">I</span><span class="z-assembly z-function z-entity z-name">_</span><span class="z-assembly z-function z-entity z-name">O</span><span class="z-assembly z-function z-entity z-name">p</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name">n</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-character z-constant z-hexadecimal">0x66</span><span class="z-assembly z-comment"> ; Open syscall</span>
</span></code></pre><p>Instead of using the <code>.code</code> directive to show that the instructions / program is starting, you use the <code>.text</code> directive, since code goes in the text section.<h1 id=java-virtual-machine-jvm><a href=#java-virtual-machine-jvm aria-label="anchor link for java-virtual-machine-jvm">#</a> Java Virtual Machine (JVM)</h1><p>Somewhat surprisingly, people have written assemblers for the JVM, assembling your program to JVM bytecode. One example is <a href=https://github.com/Sable/jasmin>Jasmin</a>, although it is very old now. <em>Why?</em> It allows you to more easily test the security and capabilities of the JVM, since you don't have to the securities of the compiler.<p>Recall that Java was initially created for running on networked embedded devices (e.g. PDAs and VCRs). This is important for understanding the design of the JVM.<p>How do you execute JVM byte code? There are 4 main ways.<ul><li>Interpreter: Reads the byte code and executes the corresponding machine code.<li>Naive JIT (Just-in-Time) Compiler: Whenever we call a method, compile it to machine code and execute.<li>Monitoring JIT Compiler: Start out interpreting monitor program activity. JIT compile the parts that are executed often or otherwise considered beneficial to compile.<li>Hardware: Some companies (e.g. AJILE) created hardware that actually targets JVM byte code as its machine code.</ul><h2 id=instruction-architecture><a href=#instruction-architecture aria-label="anchor link for instruction-architecture">##</a> Instruction Architecture</h2><p>The JVM is a stack based architecture. That means only the push and pop operations actually have operands (their data) and everything else implicitly gets its data from popping things off the stack and pushing the results back onto the stack.<p><em>What is good about the JVM being a stack machine?</em> It allows for compact instructions. It is agnostic to the registers of the machine. It allows for simpler interpreters.<p><em>What is bad about the JVM being a stack machine?</em> It requires more instructions to do basic things. Some operations become more difficult.<p>The JVM uses variable length instructions.<p>The JVM is super-optimized for programs with 4 variables, optimized for 256 variables, and bad for up to 65536 variables. <em>Why?</em> The original purpose of Java was to be on embedded devices, which don't have programs with large amounts of data.<p><em>Wait, how do these optimizations work?</em> Java stores all variables in a single local variable array, where variables are uniquely identified and referenced by an integer.<h2 id=the-jvm-and-history-of-caching><a href=#the-jvm-and-history-of-caching aria-label="anchor link for the-jvm-and-history-of-caching">##</a> The JVM and History of Caching</h2><p>If you count what JVM instructions are normally executed, most are pushes and pops. In fact, there are far more pushes than pops because arithmetic operations have implicit 2 pops and 1 push that isn't counted. About 8% of instructions executed are branches/jumps (for variable checks and loops).<p>Looking at this information, it means a jump occurs about every 12 instructions (<mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn><mjx-texatom texclass=ORD><mjx-mo class=mjx-n><mjx-c class=mjx-c2F></mjx-c></mjx-mo></mjx-texatom><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c><mjx-c class=mjx-c32></mjx-c></mjx-mn><mjx-mo class=mjx-n space=4><mjx-c class=mjx-c2248></mjx-c></mjx-mo><mjx-mn class=mjx-n space=4><mjx-c class=mjx-c38></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn><mrow data-mjx-texclass=ORD><mo>/</mo></mrow><mn>12</mn><mo>≈</mo><mn>8</mn></math></mjx-assistive-mml></mjx-container>), meaning most loops are about 12 instructions. This helped hardware designers know that caches are extremely beneficial because it means programs exhibit strong <strong>locality of reference</strong>, since programs that loop often execute the same instructions and work with contiguous arrays. This locality of reference means we can get cache hit rations of 90+%, meaning they are extremely valuable.<p>This should make sense to you as a programmer because most programs follow the pattern where they set up some data, loop for awhile, and then go on to another loop.<h2 id=jvm-calling-conventions><a href=#jvm-calling-conventions aria-label="anchor link for jvm-calling-conventions">##</a> JVM Calling Conventions</h2><p>Since Java is a stack based architecture, we pass arguments to subroutines/functions on the stack is more difficult. This is because passing them on the stack would mean we can only load the arguments on top of the stack or we would have to pop them all off the stack and load them into local variables, which is inefficient.<p>To make this more efficient, the caller puts the arguments onto the stack and then the subroutine's local variables array is made to overlap with the arguments in the caller's stack, meaning the subroutine doesn't need to copy any of the arguments and instead gets them for free.<p>For returning variables, Java guarantees that functions will only return one thing and that it is on top of the stack.<h1 id=microcode><a href=#microcode aria-label="anchor link for microcode">#</a> Microcode</h1><p>On RISC machines, every instruction maps almost directly to an actual circuit. On CISC machines, many instructions map to a collection of hardwired instructions/circuits. The collection of hardwired instructions/circuits that makes up actual instructions is called <strong>microcode</strong>. Microcode is like the subroutines of CISC machine code.<p><em>Note:</em> RISC designs are generally preferred over microcode currently because RISC instructions are easier to pipeline, avoids the overhead of microcode, and hardwired circuits can often achieve improved performance. Further, most programming is no longer done in assembly, so the ease of use of CISC ISAs is far less important. However, it still is important for implementations of CISC ISAs (e.g. x86) and is neat!<p><em>Why is microcode nice?</em> It allows less complicated chips to implement more complicated instructions, that normally would only be possible on more expensive/complicated chips. Likewise, it allows machines to emulate other instruction sets. This capability was used by IBM in its S/360 compatible computer architecture.<p>Microcode can also enable performance improvements by rewriting code in microcode rather than machine code. <em>How?</em> The machine doesn't have to fetch or decode any machine code, since the microcode is stored in the CPU itself.<p><em>Why is microcode bad?</em> Microcode is incredibly hard for a human to use and is incredibly powerful. Also, why bother have microcode when you could just have simpler machine code?<h2 id=x86-string-instructions><a href=#x86-string-instructions aria-label="anchor link for x86-string-instructions">##</a> x86 String Instructions</h2><p>Text processing was at the time an extremely important use for computers (and still is to this day). Because of this Intel decided to make highly optimized machine code instructions for doing common string operations (compare, move, scan, load, and store). These instructions were written in hand-optimized microcode.<p>These operations were written generically enough that they also allowed numeric array manipulation.<h1 id=interrupts-and-i-o><a href=#interrupts-and-i-o aria-label="anchor link for interrupts-and-i-o">#</a> Interrupts and I/O</h1><p>An <strong>interrupt</strong> is a signal to the CPU that allows it to asynchronous events. Every interrupt that triggers has a unique integer ID. The CPU contains (and the OS manages) an <strong>interrupt vector table</strong>, which maps from unique integer ID to a list of subroutines to call in response to the interrupt.<p>In general, a CPU handles an interrupt by preparing for a context switch (storing registers on stack) and then calls every interrupt handler in the interrupt vector table sequentially. When it is done, it goes back to where it was and restores its saved data.<p>Specific to the 8086, the CPU stores the flags, CS, and IP onto the stack. Then it loads the CS and IP and jumps to the loaded CS and IP, which then executes the interrupt handler. The interrupt handler then saves every register it modifiers, does what it needs to do, restores the registers, and calls <code>iret</code> (for interrupt return).<p>When an interrupt occurs, the CPU prepares for a context switch (by storing the registers onto the stack) and then goes to the interrupt vector table. It then calls the subroutine to handle the inter<p><em>Note:</em> If an entry in the interrupt vector table is empty, then the interrupt triggers a "double fault", which is like the default interrupt handler and also the interrupt-within-an-interrupt handler.<h2 id=security><a href=#security aria-label="anchor link for security">##</a> Security</h2><p>In the early days of interrupts and interrupt handlers, there were several security vulnerabilities.<p>Interrupts allowed hackers to corrupt the operating system's code by modifying the stack to point in the middle of the operating system's code (arbitrary changes to SP and SI were allowed) and then trigger an interrupt causing the hardware to overwrite part of the operating system in memory. The operating system and hardware did have ways to stop the user from directly modifying the OS's code, but they had not thought to stop hardware interrupts from modifying it.<p>This security vulnerability was solved by having the OS have a safe stack space, which users couldn't modify. Hardware then used this safe stack space for context switching.<h2 id=i-o><a href=#i-o aria-label="anchor link for i-o">##</a> I/O</h2><p>There are there main ways to do input and output:<ul><li>Programmer I/O (PIO): Very restrictive, byte oriented, hardly used anymore.<li>Memory Mapped I/O (MMIO): You reserve part of your address space to communicate with hardware devices. You then can read/write as if this were real memory, even though it is actually being mapped to another devices by the hardware.<ul><li>Devices us a <strong>programmable interrupt adapter/controller</strong>, which pretends to be memory and triggers interrupts.<li>Example: VGA text buffer.</ul><li>Direct Memory Access (DMA): High performance. Allows you to directly read and write memory on the device.<ul><li>Used for things such as network cards and hard disks where performance is critical.</ul></ul><h1 id=floating-point-numbers><a href=#floating-point-numbers aria-label="anchor link for floating-point-numbers">#</a> Floating Point Numbers</h1><p>The standard for representing floating point numbers in binary was originally set by IEEE 754-1985 in 1985. The most up to date version of the spec is IEEE 754-2008 from 2008.<p><em>Note:</em> There are some complex rules around rounding and how to deal with infinity in the spec. For this class, we'll stick to the basic idea.<p>The standard specifies 3 <em>precisions</em> of floating point numbers.<ul><li>Single precision: 32 bits.<li>Double precision: 64 bits.<li>Quadruple precision: 128 bits.</ul><p>Every precision breaks the field into a sign, exponent, and significand as detailed below. <em>Note:</em> You always store the "normalized" form of the number, that is in <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-cB1></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45B"></mjx-c></mjx-mi><mjx-mo class=mjx-n space=3><mjx-c class=mjx-cD7></mjx-c></mjx-mo><mjx-msup space=3><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c><mjx-c class=mjx-c30></mjx-c></mjx-mn><mjx-script style=vertical-align:.393em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D452"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>±</mo><mi>n</mi><mo>×</mo><msup><mn>10</mn><mi>e</mi></msup></math></mjx-assistive-mml></mjx-container>, <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn><mjx-mo class=mjx-n space=4><mjx-c class=mjx-c2264></mjx-c></mjx-mo><mjx-mi class=mjx-i space=4><mjx-c class="TEX-I mjx-c1D45B"></mjx-c></mjx-mi><mjx-mo class=mjx-n space=4><mjx-c class=mjx-c3C></mjx-c></mjx-mo><mjx-mn class=mjx-n space=4><mjx-c class=mjx-c32></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn><mo>≤</mo><mi>n</mi><mo>&lt;</mo><mn>2</mn></math></mjx-assistive-mml></mjx-container>.<ul><li>Sign (1 bit)<li>Exponent: The exponent <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D452"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>e</mi></math></mjx-assistive-mml></mjx-container> in <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-cB1></mjx-c></mjx-mo><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45B"></mjx-c></mjx-mi><mjx-mo class=mjx-n space=3><mjx-c class=mjx-cD7></mjx-c></mjx-mo><mjx-msup space=3><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c><mjx-c class=mjx-c30></mjx-c></mjx-mn><mjx-script style=vertical-align:.393em><mjx-mi class=mjx-i size=s><mjx-c class="TEX-I mjx-c1D452"></mjx-c></mjx-mi></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>±</mo><mi>n</mi><mo>×</mo><msup><mn>10</mn><mi>e</mi></msup></math></mjx-assistive-mml></mjx-container>. This is stored biased so that you have to subtract the bias from the value to get the actual exponent <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D452"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>e</mi></math></mjx-assistive-mml></mjx-container>. (The bias is always half of the fields maximum value.) The maximum and minimum exponent is always reserved for special numbers (e.g. infinity).<ul><li>Single Precision: 8 bits and 127 is the bias.</ul><li>Significand: The fractional part of <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D45B"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>n</mi></math></mjx-assistive-mml></mjx-container>. We only store the fractional part because we know that the bit before the decimal place will always be 1 because we store the normalized form of the number. (This is called the <strong>hidden bit</strong>.)</ul><p><em>This has some pitfalls though!</em><p>We have a limited number of digits so we can have rounding error. In general, Single precision numbers can handle ~7-8 significant figures, with the exact precision depending on the number.<p>Since we are using binary fractional parts, not all seemingly simple fractions can be represented exactly. For example in binary <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn><mjx-texatom texclass=ORD><mjx-mo class=mjx-n><mjx-c class=mjx-c2F></mjx-c></mjx-mo></mjx-texatom><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c><mjx-c class=mjx-c30></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn><mrow data-mjx-texclass=ORD><mo>/</mo></mrow><mn>10</mn></math></mjx-assistive-mml></mjx-container> has infinitely many repeating digits. Of course <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mi class=mjx-i><mjx-c class="TEX-I mjx-c1D70B"></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mi>π</mi></math></mjx-assistive-mml></mjx-container> also has infinitely many repeating digits.<p>To handle the rounding error and imprecision that is associated with floating point, you establish a constant small value epsilon that represents an acceptable amount of error. Then, when you check for equality, you see if the difference between the numbers is less than epsilon.<p>Outside of the rounding errors, floating point number have some special numbers that use the reserved exponents.<ul><li><mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-cB1></mjx-c></mjx-mo><mjx-mn class=mjx-n><mjx-c class=mjx-c30></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>±</mo><mn>0</mn></math></mjx-assistive-mml></mjx-container>: Everything but sign bit is 0. Sign bit acts normally.<ul><li>Because of the hidden bit, all zeros normally wouldn't actually be zero.</ul><li><mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mo class=mjx-n><mjx-c class=mjx-cB1></mjx-c></mjx-mo><mjx-mi class=mjx-n><mjx-c class=mjx-c221E></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mo>±</mo><mi mathvariant=normal>∞</mi></math></mjx-assistive-mml></mjx-container>: Exponent is maxed and significand is 0. Sign bit acts normally.<li>NaN: Sign = 1, exponent is maxed, and significand is not zero.<ul><li>All operations on NaN yield NaN.<li>Occurs when you do something invalid, like divide by zero.</ul></ul><p>Creating a NaN is an example of an exception, but there are others. Examples include overflow and underflow. However, these exceptions have default actions defined in the standard and it is common practice to accept the default action.<h2 id=floating-pointer-coprocessor-numeric-data-processor-ndp><a href=#floating-pointer-coprocessor-numeric-data-processor-ndp aria-label="anchor link for floating-pointer-coprocessor-numeric-data-processor-ndp">##</a> Floating Pointer Coprocessor / Numeric Data Processor (NDP)</h2><p>Historically, many computers did not have native floating point operations (instead emulating it in software) and those who did shelled out to a completely different chip in the system which would perform the operations. Nowadays, most consumer computers have the floating point coprocessor on the same chip as the main CPU, but it is still acts like a coprocessor.<p>Communication with the coprocessor is done via the <strong>floating point register stack</strong>. The top of the stack is called <code>ST</code> or stack top. The processor treats this as a <em>pure</em> stack, limiting you to the following operations.<ul><li><code>fld dest</code>: Load real. Push a real number onto the stack.<li><code>fst[bw] dest</code>: Peek at the top of the stack.<li><code>fstp[bw] dest</code>: Pop a real number off of the stack.<li><code>fadd</code>: <code>ST(1) + ST</code>.<li><code>fsub</code>: <code>ST(1) - ST</code>.<li><code>fmul</code>: <code>ST(1) * ST</code>.<li><code>fdiv</code>: <code>ST(1) / ST</code>.<li><code>fwait</code>: Wait for NDP to complete store. Should be done after trying to read from the coprocessor.</ul><p>The NDP has a <strong>status word</strong>, which provides information about its current state. Two of the bits, C3 and C0, show the comparison of <code>ST(1)</code> and <code>ST</code>.<ul><li><code>ST(1) > ST</code>: C3 = 0. C0 = 0.<li><code>ST(1) &lt; ST</code>: C3 = 0. C0 = 1.<li><code>ST(1) = ST</code>: C3 = 1. C0 = 0.<li><code>ST(1) ? ST</code>: C3 = 1. C0 = 1. This occurs when you cannot compare the numbers, for example of one of the numbers is NaN.</ul><p>Neat! How do we use that? Well, if you move the high byte of the NDP status register into the low byte of the x86 status register, C3 corresponds to ZF and C0 corresponds to CF. This correspondence was done intentionally because then <code>ja</code>, <code>jb</code>, and <code>je</code> have their exact expected meaning.<h1 id=computer-architecture-design><a href=#computer-architecture-design aria-label="anchor link for computer-architecture-design">#</a> Computer Architecture Design</h1><p>In general, shorter instructions are better (delivered faster and smaller binaries), fixed-length instructions are better (easier to decode), and instructions are all sized in full bytes (easier to address, no 12-bit instructions).<h2 id=explicit-vs-implicit-operands><a href=#explicit-vs-implicit-operands aria-label="anchor link for explicit-vs-implicit-operands">##</a> Explicit vs Implicit Operands</h2><p>One important decision is the number of explicit vs implicit operands an instruction has.<p>Consider four machines: M0 has no explicit operands, M1 has one, M2 has two, and M3 has three. Let's see how they calculate <code>C = A + B</code>.<p>M0 is normally called a stack machine. All operations push and pop things off the stack. Load/push and store/pop are the only exceptions and they have one operand.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-control z-keyword">push</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">A</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-control z-keyword">push</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">B</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-control z-keyword">add</span>
<span class="z-assembly z-control z-keyword">pop</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">C</span><span class="z-assembly z-source">]</span>
</span></code></pre><p>M1 is normally called accumulator machines because all loads load into the accumulator, all arithmetic uses the accumulator as a source and a destination, and all stores store the accumulator.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-function z-entity z-name">l</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">a</span><span class="z-assembly z-function z-entity z-name">d</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">A</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-control z-keyword">add</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">B</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-function z-entity z-name">s</span><span class="z-assembly z-function z-entity z-name">t</span><span class="z-assembly z-function z-entity z-name">o</span><span class="z-assembly z-function z-entity z-name">r</span><span class="z-assembly z-function z-entity z-name">e</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">C</span><span class="z-assembly z-source">]</span>
</span></code></pre><p>M2 is (close to) what the 8086 is. Load and store have their two expected operands. All arithmetic uses one of the registers as both a source and destination.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-control z-keyword">mov</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">C</span><span class="z-assembly z-source">]</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">A</span><span class="z-assembly z-source">]</span>
<span class="z-assembly z-control z-keyword">add</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">C</span><span class="z-assembly z-source">]</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">B</span><span class="z-assembly z-source">]</span>
</span></code></pre><p>M3 is (close to) what ARM is. You explicitly list all operands for all instructions.<pre class="language-asm z-code" data-lang=asm><code class=language-asm data-lang=asm><span class="z-assembly z-source"><span class="z-assembly z-control z-keyword">add</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">C</span><span class="z-assembly z-source">]</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">A</span><span class="z-assembly z-source">]</span><span class="z-assembly z-source">,</span><span class="z-assembly z-function z-entity z-name"> </span><span class="z-assembly z-source">[</span><span class="z-assembly z-function z-entity z-name">B</span><span class="z-assembly z-source">]</span>
</span></code></pre><p>The 8086 is close to M2 because there are restrictions on what the operands can be (i.e. no memory to memory). ARM is close to M3 because there are restrictions on what the operands can be (i.e. only registers).<p>Let's pretend we have a machine with the following specs<ul><li>Cycle Time: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn></math></mjx-assistive-mml></mjx-container> us (<mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn></math></mjx-assistive-mml></mjx-container> MHz)<li>Memory Rate: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-msup><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c><mjx-c class=mjx-c30></mjx-c></mjx-mn><mjx-script style=vertical-align:.393em><mjx-mn class=mjx-n size=s><mjx-c class=mjx-c36></mjx-c></mjx-mn></mjx-script></mjx-msup></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><msup><mn>10</mn><mn>6</mn></msup></math></mjx-assistive-mml></mjx-container> bytes/sec<li>Fetch Instruction: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn></math></mjx-assistive-mml></mjx-container> us / byte<li>Decode Opcode: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn></math></mjx-assistive-mml></mjx-container> us<li>Access Data: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn></math></mjx-assistive-mml></mjx-container> us / operand<li>Execute: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c32></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>2</mn></math></mjx-assistive-mml></mjx-container> us<li>Opcode: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c31></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn></math></mjx-assistive-mml></mjx-container> byte<li>Operand: <mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative><mjx-math aria-hidden=true class=MJX-TEX><mjx-mn class=mjx-n><mjx-c class=mjx-c32></mjx-c></mjx-mn></mjx-math><mjx-assistive-mml display=inline unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML><mn>2</mn></math></mjx-assistive-mml></mjx-container> bytes</ul><p>This gives us the following table. <em>Note:</em> We leave off M0 because it requires memory addressing for some instructions but not others and thus complicates analysis.<table><thead><tr><th>Part<th>M1<th>M2<th>M3<tbody><tr><td>Fetch<td>3<td>5<td>7<tr><td>Decode<td>1<td>1<td>1<tr><td>Data<td>1<td>2<td>3<tr><td>Execute<td>2<td>2<td>2<tr><td>1 instr<td>7<td>10<td>13<tr><td><code>C = A + B</code><td>21<td>20<td>13<tr><td>instr / sec<td>142,857<td>100,000<td>76,923</table><p>Notice something from this analysis. All machines have the exact same clock speed but execute different number of instructions per second. Further, the machine that executes instructions the fastest was the slowest to run our program while the machine that executes instructions the slowest was the fastest to run our program. <em>Answering which machine is the fastest is extremely difficult and will depend on the program!</em><p>In general, to compare machines we need to know clock speed, instruction execution rate, capability of each instruction, and a specific task to perform (i.e. benchmark). Then, the time for the instruction is given by the following<p><mjx-container class=MathJax jax=CHTML style=font-size:113.1%;position:relative display=true><mjx-math aria-hidden=true class=MJX-TEX display=true style=margin-left:0;margin-right:0><mjx-mtext class=mjx-n><mjx-c class=mjx-c74></mjx-c><mjx-c class=mjx-c69></mjx-c><mjx-c class=mjx-c6D></mjx-c><mjx-c class=mjx-c65></mjx-c></mjx-mtext><mjx-mo class=mjx-n space=4><mjx-c class=mjx-c3D></mjx-c></mjx-mo><mjx-mfrac space=4><mjx-frac type=d><mjx-num><mjx-nstrut type=d></mjx-nstrut><mjx-mrow><mjx-mo class=mjx-sop><mjx-c class="mjx-c2211 TEX-S1"></mjx-c></mjx-mo><mjx-texatom texclass=ORD space=2><mjx-mtext class=mjx-n><mjx-c class=mjx-c69></mjx-c><mjx-c class=mjx-c6E></mjx-c><mjx-c class=mjx-c73></mjx-c><mjx-c class=mjx-c74></mjx-c><mjx-c class=mjx-c72></mjx-c><mjx-c class=mjx-c75></mjx-c><mjx-c class=mjx-c63></mjx-c><mjx-c class=mjx-c74></mjx-c><mjx-c class=mjx-c69></mjx-c><mjx-c class=mjx-c6F></mjx-c><mjx-c class=mjx-c6E></mjx-c><mjx-c class=mjx-c73></mjx-c></mjx-mtext></mjx-texatom></mjx-mrow></mjx-num><mjx-dbox><mjx-dtable><mjx-line type=d></mjx-line><mjx-row><mjx-den><mjx-dstrut type=d></mjx-dstrut><mjx-mtext class=mjx-n><mjx-c class=mjx-c74></mjx-c><mjx-c class=mjx-c61></mjx-c><mjx-c class=mjx-c73></mjx-c><mjx-c class=mjx-c6B></mjx-c></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class=mjx-n space=3><mjx-c class=mjx-c2217></mjx-c></mjx-mo><mjx-mfrac space=3><mjx-frac type=d><mjx-num><mjx-nstrut type=d></mjx-nstrut><mjx-mtext class=mjx-n><mjx-c class=mjx-c63></mjx-c><mjx-c class=mjx-c79></mjx-c><mjx-c class=mjx-c63></mjx-c><mjx-c class=mjx-c6C></mjx-c><mjx-c class=mjx-c65></mjx-c><mjx-c class=mjx-c73></mjx-c></mjx-mtext></mjx-num><mjx-dbox><mjx-dtable><mjx-line type=d></mjx-line><mjx-row><mjx-den><mjx-dstrut type=d></mjx-dstrut><mjx-mtext class=mjx-n><mjx-c class=mjx-c69></mjx-c><mjx-c class=mjx-c6E></mjx-c><mjx-c class=mjx-c73></mjx-c><mjx-c class=mjx-c74></mjx-c><mjx-c class=mjx-c72></mjx-c></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac><mjx-mo class=mjx-n space=3><mjx-c class=mjx-c2217></mjx-c></mjx-mo><mjx-mfrac space=3><mjx-frac type=d><mjx-num><mjx-nstrut type=d></mjx-nstrut><mjx-mtext class=mjx-n><mjx-c class=mjx-c73></mjx-c><mjx-c class=mjx-c65></mjx-c><mjx-c class=mjx-c63></mjx-c><mjx-c class=mjx-c6F></mjx-c><mjx-c class=mjx-c6E></mjx-c><mjx-c class=mjx-c64></mjx-c><mjx-c class=mjx-c73></mjx-c></mjx-mtext></mjx-num><mjx-dbox><mjx-dtable><mjx-line type=d></mjx-line><mjx-row><mjx-den><mjx-dstrut type=d></mjx-dstrut><mjx-mtext class=mjx-n><mjx-c class=mjx-c63></mjx-c><mjx-c class=mjx-c79></mjx-c><mjx-c class=mjx-c63></mjx-c><mjx-c class=mjx-c6C></mjx-c><mjx-c class=mjx-c65></mjx-c></mjx-mtext></mjx-den></mjx-row></mjx-dtable></mjx-dbox></mjx-frac></mjx-mfrac></mjx-math><mjx-assistive-mml display=block unselectable=on><math xmlns=http://www.w3.org/1998/Math/MathML display=block><mtext>time</mtext><mo>=</mo><mfrac><mrow><mo data-mjx-texclass=OP>∑</mo><mrow data-mjx-texclass=ORD><mtext>instructions</mtext></mrow></mrow><mtext>task</mtext></mfrac><mo>∗</mo><mfrac><mtext>cycles</mtext><mtext>instr</mtext></mfrac><mo>∗</mo><mfrac><mtext>seconds</mtext><mtext>cycle</mtext></mfrac></math></mjx-assistive-mml></mjx-container><p><em>Note:</em> The benchmark must be fair (i.e. don't use benchmarks that are helped special capabilities) and accurate (i.e. be careful about the compiler being smarter than your synthetic benchmark by doing dead-code elimination, etc.).<h2 id=caching><a href=#caching aria-label="anchor link for caching">##</a> Caching</h2><p>If we built RAM only using transistors (static RAM), it would be extremely efficient but extremely expensive. Instead we use much cheaper static RAM using transistors and capacitors. To get around the slow performance of dynamic RAM, we use a very small extremely efficient cache. <em>Why does this work?</em> Many programs exhibit locality of reference because of loops and most memory structures are nearby each other (e.g. arrays).<p><em>Note:</em> Some page replacement algorithms exhibit Belady's Anomaly, where more cache reduces performance. Algorithms that don't exhibit this are called <strong>stack algorithms.</strong><h2 id=pipelining><a href=#pipelining aria-label="anchor link for pipelining">##</a> Pipelining</h2><p>Often instructions are executed in different independent stages (e.g. fetch, decode, execute). We can improve efficiency by always having an instruction in each of these stages. This is called <strong>pipelining.</strong><p>In general, this is excellent for performance. However, it does have an issue with conditional branching. Namely, if you hit a branch you have to wait to execute the branch to find the next instruction. This is called having a <strong>bubble in the pipeline.</strong><p>This can be mitigated using speculative execution, where you predict that the branch will / won't be executed. If you guess wrong, you have to drain the pipeline and it's just as bad as if you just waited. If you guessed right, then it's like you had no jump.<p><em>How do you predict whether or not you'll take the jump?</em> You could use a global prediction from instructions executed. You could provide different instructions / a bit in the opcode that says whether this jump is likely to be taken or not and then have the compiler / programmer pick the appropriate one. You could dynamically keep track of whether that branch tends to be taken, but that incurs additional overhead and complexity.<p>This can also be mitigated by having hardware that can do the first few stages of the pipeline for the two different possible instructions, until you figure out which one you should have executed. That is, take both paths and clean it up afterwards. This is the best performance always, but it is also expensive.<p>This can also be mitigated by using a <strong>delayed branching architecture.</strong> That is, you say you will always execute the instruction immediately after a jump. This ensures that you will never drain the pipeline or guess incorrectly and thus improves performance. The key issue is that you need to find a instruction that will always be executed in both cases that you can insert into the <strong>delay slot.</strong> I personally am not convinced that this is better than just having "maybe yes" vs "maybe no" jumps, especially because it gets harder the longer your pipeline becomes since you get more and more delay slots. Some examples of programs that use this are MIPS and SPARC.<p>In general, longer pipelines tend to have a faster steady state (speed once pipeline is saturated) but slower latency (time it takes for pipeline to be saturated). They also tend to take longer to recover from bubbles in the pipeline. Since pipelines are drained reasonably regularly, latency is often important.<h1 id=newer-x86><a href=#newer-x86 aria-label="anchor link for newer-x86">#</a> Newer x86</h1><p>Pentium processors and beyond are actually RISC machines that have a CISC frontend layered on top of them. Basically, they have a RISC microcode that actually does all the work. Then they have a CISC decode, that reads in the complex instructions and converts them into microcode that actually gets executed. <em>Note:</em> Some RISC-like instructions, such as adding two registers, are sent directly to the RISC core.<p>The Pentium did out-of-order instruction execution, more sophisticated speculative execution using dynamic branch prediction, and did superscalar execution.<p><em>Note:</em> The Pentium 4 had a 20-stage pipeline, largely to allow it to pump up its clock rate, since that was (and still is) huge for marketing. This was the main motivation for Intel to have such complex and sophisticated branch prediction.<h2 id=branch-prediction><a href=#branch-prediction aria-label="anchor link for branch-prediction">##</a> Branch Prediction</h2><p>The original Pentium 1's branch prediction algorithm was accurate on average 75% of the time. It's algorithm was the following pseudo-code.<pre class="z-code language-nohighlight" data-lang=nohighlight><code class=language-nohighlight data-lang=nohighlight><span class="z-plain z-text"># The 2 bit number is how many time's
# we've seen the branch since we took it,
# with 11 being the max.
history = 2 bit history of jumps taken
if branch not in history:
  if branch goes forward:
    don't take branch
  else:
    # It's probably a loop
    take branch
else:
  if history[branch] != 11:
    take branch
  else:
    don't take branch
</span></code></pre><p>This is clever because it allows us to be wrong once and still say we should jump again to properly handle nested loops.<h2 id=reduced-operations><a href=#reduced-operations aria-label="anchor link for reduced-operations">##</a> Reduced Operations</h2><p>Every instruction is broken down into 1-4 reduced operations (ROPS), which specify with painful detail the steps required to perform the operation. If an instruction (e.g. a string instruction) cannot be broken down that far, it is passed to the microcode ROM.<p>These ROPS additionally have a speculative bit, that says whether the operation is being done speculatively, meaning you may have to trash your work. These ROPS are queued onto their appropriate unit (e.g. they need an integer ALU, floating point ALU, load store module, jxx module, etc.). Sometimes there's even multiple of these units for performance.<p>These ROPS have additional "scratch" registers which they can work with, which the programmer does not get access to.<p>Scheduling these ROPS on distinct units allows for out-of-order and parallel operation execution, which is what we want.<h1 id=hardware-description-languages><a href=#hardware-description-languages aria-label="anchor link for hardware-description-languages">#</a> Hardware Description Languages</h1><p>Nowadays, most hardware is designed using a <strong>hardware description language</strong>, such as Verilog that produces the actual circuitry from the hardware description. This is advantageous because it means automated testing / verification of hardware correctness can be done and allows much easier and more rapid development of hardware.<p>Also, if the language is flexible / powerful enough, the programmer should lose little to no control over the design of the hardware and instead is empowered to make more powerful and complex designs.</article>